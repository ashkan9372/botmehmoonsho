/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdateproj"]("chunk-vendors",{

/***/ "./node_modules/jalali-moment/jalali-moment.js":
/*!*****************************************************!*\
  !*** ./node_modules/jalali-moment/jalali-moment.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = jMoment;\nvar moment = __webpack_require__(/*! moment/moment */ \"./node_modules/moment/moment.js\");\n__webpack_require__(/*! moment/locale/fa */ \"./node_modules/moment/locale/fa.js\");\n\n/************************************\n Constants\n ************************************/\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?j(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?|)|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,\n  localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LT|LL?L?L?|l{1,4})/g,\n  parseTokenOneOrTwoDigits = /\\d\\d?/,\n  parseTokenOneToThreeDigits = /\\d{1,3}/,\n  parseTokenThreeDigits = /\\d{3}/,\n  parseTokenFourDigits = /\\d{1,4}/,\n  parseTokenSixDigits = /[+\\-]?\\d{1,6}/,\n  parseTokenWord = /[0-9]*[\"a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i,\n  parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/i,\n  parseTokenT = /T/i,\n  parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/,\n  unitAliases = {\n    jm: \"jmonth\",\n    jmonths: \"jmonth\",\n    jy: \"jyear\",\n    jyears: \"jyear\"\n  },\n  formatFunctions = {},\n  ordinalizeTokens = \"DDD w M D\".split(\" \"),\n  paddedTokens = \"M D w\".split(\" \");\nvar CalendarSystems = {\n  Jalali: 1,\n  Gregorian: 2\n};\nvar formatTokenFunctions = {\n  jM: function () {\n    return this.jMonth() + 1;\n  },\n  jMMM: function (format) {\n    return this.localeData().jMonthsShort(this, format);\n  },\n  jMMMM: function (format) {\n    return this.localeData().jMonths(this, format);\n  },\n  jD: function () {\n    return this.jDate();\n  },\n  jDDD: function () {\n    return this.jDayOfYear();\n  },\n  jw: function () {\n    return this.jWeek();\n  },\n  jYY: function () {\n    return leftZeroFill(this.jYear() % 100, 2);\n  },\n  jYYYY: function () {\n    return leftZeroFill(this.jYear(), 4);\n  },\n  jYYYYY: function () {\n    return leftZeroFill(this.jYear(), 5);\n  },\n  jgg: function () {\n    return leftZeroFill(this.jWeekYear() % 100, 2);\n  },\n  jgggg: function () {\n    return this.jWeekYear();\n  },\n  jggggg: function () {\n    return leftZeroFill(this.jWeekYear(), 5);\n  }\n};\nfunction padToken(func, count) {\n  return function (a) {\n    return leftZeroFill(func.call(this, a), count);\n  };\n}\nfunction ordinalizeToken(func, period) {\n  return function (a) {\n    return this.localeData().ordinal(func.call(this, a), period);\n  };\n}\n(function () {\n  var i;\n  while (ordinalizeTokens.length) {\n    i = ordinalizeTokens.pop();\n    formatTokenFunctions[\"j\" + i + \"o\"] = ordinalizeToken(formatTokenFunctions[\"j\" + i], i);\n  }\n  while (paddedTokens.length) {\n    i = paddedTokens.pop();\n    formatTokenFunctions[\"j\" + i + i] = padToken(formatTokenFunctions[\"j\" + i], 2);\n  }\n  formatTokenFunctions.jDDDD = padToken(formatTokenFunctions.jDDD, 3);\n})();\n\n/************************************\n Helpers\n ************************************/\n\nfunction extend(a, b) {\n  var key;\n  for (key in b) if (b.hasOwnProperty(key)) {\n    a[key] = b[key];\n  }\n  return a;\n}\n\n/**\n * return a string which length is as much as you need\n * @param {number} number input\n * @param {number} targetLength expected length\n * @example leftZeroFill(5,2) => 05\n **/\nfunction leftZeroFill(number, targetLength) {\n  var output = number + \"\";\n  while (output.length < targetLength) {\n    output = \"0\" + output;\n  }\n  return output;\n}\n\n/**\n * determine object is array or not\n * @param input\n **/\nfunction isArray(input) {\n  return Object.prototype.toString.call(input) === \"[object Array]\";\n}\n\n/**\n * Changes any moment Gregorian format to Jalali system format\n * @param {string} format\n * @example toJalaliFormat(\"YYYY/MMM/DD\") => \"jYYYY/jMMM/jDD\"\n **/\nfunction toJalaliFormat(format) {\n  for (var i = 0; i < format.length; i++) {\n    if (!i || format[i - 1] !== \"j\" && format[i - 1] !== format[i]) {\n      if (format[i] === \"Y\" || format[i] === \"M\" || format[i] === \"D\" || format[i] === \"g\") {\n        format = format.slice(0, i) + \"j\" + format.slice(i);\n      }\n    }\n  }\n  return format;\n}\n\n/**\n * Changes any moment Gregorian units to Jalali system units\n * @param {string} units\n * @example toJalaliUnit(\"YYYY/MMM/DD\") => \"jYYYY/jMMM/jDD\"\n **/\nfunction toJalaliUnit(units) {\n  switch (units) {\n    case \"week\":\n      return \"jWeek\";\n    case \"year\":\n      return \"jYear\";\n    case \"month\":\n      return \"jMonth\";\n    case \"months\":\n      return \"jMonths\";\n    case \"monthName\":\n      return \"jMonthsShort\";\n    case \"monthsShort\":\n      return \"jMonthsShort\";\n  }\n  return units;\n}\n\n/**\n * normalize units to be comparable\n * @param {string} units\n **/\nfunction normalizeUnits(units, momentObj) {\n  if (isJalali(momentObj)) {\n    units = toJalaliUnit(units);\n  }\n  if (units) {\n    var lowered = units.toLowerCase();\n    if (lowered.startsWith('j')) units = unitAliases[lowered] || lowered;\n    // TODO : add unit test\n    if (units === \"jday\") units = \"day\";else if (units === \"jd\") units = \"d\";\n  }\n  return units;\n}\n\n/**\n * set a gregorian date to moment object\n * @param {string} momentInstance\n * @param {string} year in gregorian system\n * @param {string} month in gregorian system\n * @param {string} day in gregorian system\n **/\nfunction setDate(momentInstance, year, month, day) {\n  var d = momentInstance._d;\n  if (momentInstance._isUTC) {\n    /*eslint-disable new-cap*/\n    momentInstance._d = new Date(Date.UTC(year, month, day, d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()));\n    /*eslint-enable new-cap*/\n  } else {\n    momentInstance._d = new Date(year, month, day, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n  }\n}\nfunction objectCreate(parent) {\n  function F() {}\n  F.prototype = parent;\n  return new F();\n}\nfunction getPrototypeOf(object) {\n  if (Object.getPrototypeOf) {\n    return Object.getPrototypeOf(object);\n  } else if (\"\".__proto__) {\n    return object.__proto__;\n  } else {\n    return object.constructor.prototype;\n  }\n}\n\n/************************************\n Languages\n ************************************/\nextend(getPrototypeOf(moment.localeData()), {\n  _jMonths: [\"Farvardin\", \"Ordibehesht\", \"Khordaad\", \"Tir\", \"Mordaad\", \"Shahrivar\", \"Mehr\", \"Aabaan\", \"Aazar\", \"Dey\", \"Bahman\", \"Esfand\"],\n  jMonths: function (m) {\n    if (m) {\n      return this._jMonths[m.jMonth()];\n    } else {\n      return this._jMonths;\n    }\n  },\n  _jMonthsShort: [\"Far\", \"Ord\", \"Kho\", \"Tir\", \"Amo\", \"Sha\", \"Meh\", \"Aab\", \"Aaz\", \"Dey\", \"Bah\", \"Esf\"],\n  jMonthsShort: function (m) {\n    if (m) {\n      return this._jMonthsShort[m.jMonth()];\n    } else {\n      return this._jMonthsShort;\n    }\n  },\n  jMonthsParse: function (monthName) {\n    var i, mom, regex;\n    if (!this._jMonthsParse) {\n      this._jMonthsParse = [];\n    }\n    for (i = 0; i < 12; i += 1) {\n      // Make the regex if we don\"t have it already.\n      if (!this._jMonthsParse[i]) {\n        mom = jMoment([2000, (2 + i) % 12, 25]);\n        regex = \"^\" + this.jMonths(mom, \"\") + \"|^\" + this.jMonthsShort(mom, \"\");\n        this._jMonthsParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n      }\n      // Test the regex.\n      if (this._jMonthsParse[i].test(monthName)) {\n        return i;\n      }\n    }\n  }\n});\n\n/************************************\n Formatting\n ************************************/\n\nfunction makeFormatFunction(format) {\n  var array = format.match(formattingTokens),\n    length = array.length,\n    i;\n  for (i = 0; i < length; i += 1) {\n    if (formatTokenFunctions[array[i]]) {\n      array[i] = formatTokenFunctions[array[i]];\n    }\n  }\n  return function (mom) {\n    var output = \"\";\n    for (i = 0; i < length; i += 1) {\n      output += array[i] instanceof Function ? \"[\" + array[i].call(mom, format) + \"]\" : array[i];\n    }\n    return output;\n  };\n}\n\n/************************************\n Parsing\n ************************************/\n\nfunction getParseRegexForToken(token, config) {\n  switch (token) {\n    case \"jDDDD\":\n      return parseTokenThreeDigits;\n    case \"jYYYY\":\n      return parseTokenFourDigits;\n    case \"jYYYYY\":\n      return parseTokenSixDigits;\n    case \"jDDD\":\n      return parseTokenOneToThreeDigits;\n    case \"jMMM\":\n    case \"jMMMM\":\n      return parseTokenWord;\n    case \"jMM\":\n    case \"jDD\":\n    case \"jYY\":\n    case \"jM\":\n    case \"jD\":\n      return parseTokenOneOrTwoDigits;\n    case \"DDDD\":\n      return parseTokenThreeDigits;\n    case \"YYYY\":\n      return parseTokenFourDigits;\n    case \"YYYYY\":\n      return parseTokenSixDigits;\n    case \"S\":\n    case \"SS\":\n    case \"SSS\":\n    case \"DDD\":\n      return parseTokenOneToThreeDigits;\n    case \"MMM\":\n    case \"MMMM\":\n    case \"dd\":\n    case \"ddd\":\n    case \"dddd\":\n      return parseTokenWord;\n    case \"a\":\n    case \"A\":\n      return moment.localeData(config._l)._meridiemParse;\n    case \"X\":\n      return parseTokenTimestampMs;\n    case \"Z\":\n    case \"ZZ\":\n      return parseTokenTimezone;\n    case \"T\":\n      return parseTokenT;\n    case \"MM\":\n    case \"DD\":\n    case \"YY\":\n    case \"HH\":\n    case \"hh\":\n    case \"mm\":\n    case \"ss\":\n    case \"M\":\n    case \"D\":\n    case \"d\":\n    case \"H\":\n    case \"h\":\n    case \"m\":\n    case \"s\":\n      return parseTokenOneOrTwoDigits;\n    default:\n      return new RegExp(token.replace(\"\\\\\", \"\"));\n  }\n}\nfunction isNull(variable) {\n  return variable === null || variable === undefined;\n}\nfunction addTimeToArrayFromToken(token, input, config) {\n  var a,\n    datePartArray = config._a;\n  switch (token) {\n    case \"jM\":\n    case \"jMM\":\n      datePartArray[1] = isNull(input) ? 0 : ~~input - 1;\n      break;\n    case \"jMMM\":\n    case \"jMMMM\":\n      a = moment.localeData(config._l).jMonthsParse(input);\n      if (!isNull(a)) {\n        datePartArray[1] = a;\n      } else {\n        config._isValid = false;\n      }\n      break;\n    case \"jD\":\n    case \"jDD\":\n    case \"jDDD\":\n    case \"jDDDD\":\n      if (!isNull(input)) {\n        datePartArray[2] = ~~input;\n      }\n      break;\n    case \"jYY\":\n      datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400);\n      break;\n    case \"jYYYY\":\n    case \"jYYYYY\":\n      datePartArray[0] = ~~input;\n  }\n  if (isNull(input)) {\n    config._isValid = false;\n  }\n}\nfunction dateFromArray(config) {\n  var g,\n    j,\n    jy = config._a[0],\n    jm = config._a[1],\n    jd = config._a[2];\n  if (isNull(jy) && isNull(jm) && isNull(jd)) {\n    return;\n  }\n  jy = !isNull(jy) ? jy : 0;\n  jm = !isNull(jm) ? jm : 0;\n  jd = !isNull(jd) ? jd : 1;\n  if (jd < 1 || jd > jMoment.jDaysInMonth(jy, jm) || jm < 0 || jm > 11) {\n    config._isValid = false;\n  }\n  g = toGregorian(jy, jm, jd);\n  j = toJalali(g.gy, g.gm, g.gd);\n  config._jDiff = 0;\n  if (~~j.jy !== jy) {\n    config._jDiff += 1;\n  }\n  if (~~j.jm !== jm) {\n    config._jDiff += 1;\n  }\n  if (~~j.jd !== jd) {\n    config._jDiff += 1;\n  }\n  return [g.gy, g.gm, g.gd];\n}\nfunction makeDateFromStringAndFormat(config) {\n  var tokens = config._f.match(formattingTokens),\n    string = config._i + \"\",\n    len = tokens.length,\n    i,\n    token,\n    parsedInput;\n  config._a = [];\n  for (i = 0; i < len; i += 1) {\n    token = tokens[i];\n    parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];\n    if (parsedInput) {\n      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n    }\n    if (formatTokenFunctions[token]) {\n      addTimeToArrayFromToken(token, parsedInput, config);\n    }\n  }\n  if (string) {\n    config._il = string;\n  }\n  return dateFromArray(config);\n}\nfunction makeDateFromStringAndArray(config, utc) {\n  var len = config._f.length,\n    i,\n    format,\n    tempMoment,\n    bestMoment,\n    currentScore,\n    scoreToBeat;\n  if (len === 0) {\n    return makeMoment(new Date(NaN));\n  }\n  for (i = 0; i < len; i += 1) {\n    format = config._f[i];\n    currentScore = 0;\n    tempMoment = makeMoment(config._i, format, config._l, config._strict, utc);\n    if (!tempMoment.isValid()) {\n      continue;\n    }\n\n    // currentScore = compareArrays(tempMoment._a, tempMoment.toArray())\n    currentScore += tempMoment._jDiff;\n    if (tempMoment._il) {\n      currentScore += tempMoment._il.length;\n    }\n    if (isNull(scoreToBeat) || currentScore < scoreToBeat) {\n      scoreToBeat = currentScore;\n      bestMoment = tempMoment;\n    }\n  }\n  return bestMoment;\n}\nfunction removeParsedTokens(config) {\n  var string = config._i + \"\",\n    input = \"\",\n    format = \"\",\n    array = config._f.match(formattingTokens),\n    len = array.length,\n    i,\n    match,\n    parsed;\n  for (i = 0; i < len; i += 1) {\n    match = array[i];\n    parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];\n    if (parsed) {\n      string = string.slice(string.indexOf(parsed) + parsed.length);\n    }\n    if (!(formatTokenFunctions[match] instanceof Function)) {\n      format += match;\n      if (parsed) {\n        input += parsed;\n      }\n    }\n  }\n  config._i = input;\n  config._f = format;\n}\n\n/************************************\n Week of Year\n ************************************/\n\nfunction jWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n  var end = firstDayOfWeekOfYear - firstDayOfWeek,\n    daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n    adjustedMoment;\n  if (daysToDayOfWeek > end) {\n    daysToDayOfWeek -= 7;\n  }\n  if (daysToDayOfWeek < end - 7) {\n    daysToDayOfWeek += 7;\n  }\n  adjustedMoment = jMoment(mom).add(daysToDayOfWeek, \"d\");\n  return {\n    week: Math.ceil(adjustedMoment.jDayOfYear() / 7),\n    year: adjustedMoment.jYear()\n  };\n}\n\n/************************************\n Top Level Functions\n ************************************/\nfunction isJalali(momentObj) {\n  return momentObj && momentObj.calSystem === CalendarSystems.Jalali || moment.justUseJalali && momentObj.calSystem !== CalendarSystems.Gregorian;\n}\nfunction isInputJalali(format, momentObj, input) {\n  return moment.justUseJalali || momentObj && momentObj.calSystem === CalendarSystems.Jalali;\n}\nfunction makeMoment(input, format, lang, strict, utc) {\n  if (typeof lang === \"boolean\") {\n    utc = utc || strict;\n    strict = lang;\n    lang = undefined;\n  }\n  if (moment.ISO_8601 === format) {\n    format = 'YYYY-MM-DDTHH:mm:ss.SSSZ';\n  }\n  const inputIsJalali = isInputJalali(format, this, input);\n  // var itsJalaliDate = (isJalali(this));\n  if (input && typeof input === \"string\" && !format && inputIsJalali && !moment.useGregorianParser) {\n    input = input.replace(/\\//g, \"-\");\n    if (/\\d{4}\\-\\d{2}\\-\\d{2}/.test(input)) {\n      format = \"jYYYY-jMM-jDD\";\n    } else if (/\\d{4}\\-\\d{2}\\-\\d{1}/.test(input)) {\n      format = \"jYYYY-jMM-jD\";\n    } else if (/\\d{4}\\-\\d{1}\\-\\d{1}/.test(input)) {\n      format = \"jYYYY-jM-jD\";\n    } else if (/\\d{4}\\-\\d{1}\\-\\d{2}/.test(input)) {\n      format = \"jYYYY-jM-jDD\";\n    } else if (/\\d{4}\\-W\\d{2}\\-\\d{2}/.test(input)) {\n      format = \"jYYYY-jW-jDD\";\n    } else if (/\\d{4}\\-\\d{3}/.test(input)) {\n      format = \"jYYYY-jDDD\";\n    } else if (/\\d{8}/.test(input)) {\n      format = \"jYYYYjMMjDD\";\n    } else if (/\\d{4}W\\d{2}\\d{1}/.test(input)) {\n      format = \"jYYYYjWWjD\";\n    } else if (/\\d{4}W\\d{2}/.test(input)) {\n      format = \"jYYYYjWW\";\n    } else if (/\\d{4}\\d{3}/.test(input)) {\n      format = \"jYYYYjDDD\";\n    }\n  }\n  if (format && inputIsJalali) {\n    format = toJalaliFormat(format);\n  }\n  if (format && typeof format === \"string\") {\n    format = fixFormat(format, moment);\n  }\n  var config = {\n      _i: input,\n      _f: format,\n      _l: lang,\n      _strict: strict,\n      _isUTC: utc\n    },\n    date,\n    m,\n    jm,\n    origInput = input,\n    origFormat = format;\n  if (format) {\n    if (isArray(format)) {\n      return makeDateFromStringAndArray(config, utc);\n    } else {\n      date = makeDateFromStringAndFormat(config);\n      removeParsedTokens(config);\n      if (date) {\n        format = \"YYYY-MM-DD-\" + config._f;\n        input = leftZeroFill(date[0], 4) + \"-\" + leftZeroFill(date[1] + 1, 2) + \"-\" + leftZeroFill(date[2], 2) + \"-\" + config._i;\n      }\n    }\n  }\n  if (utc) {\n    m = moment.utc(input, format, lang, strict);\n  } else {\n    m = moment(input, format, lang, strict);\n  }\n  if (config._isValid === false || input && input._isAMomentObject && !input._isValid) {\n    m._isValid = false;\n  }\n  m._jDiff = config._jDiff || 0;\n  jm = objectCreate(jMoment.fn);\n  extend(jm, m);\n  if (strict && jm.isValid()) {\n    jm._isValid = jm.format(origFormat) === origInput;\n  }\n  if (input && input.calSystem) {\n    jm.calSystem = input.calSystem;\n  }\n  return jm;\n}\nfunction jMoment(input, format, lang, strict) {\n  return makeMoment(input, format, lang, strict, false);\n}\nextend(jMoment, moment);\njMoment.fn = objectCreate(moment.fn);\njMoment.utc = function (input, format, lang, strict) {\n  return makeMoment(input, format, lang, strict, true);\n};\njMoment.unix = function (input) {\n  return makeMoment(input * 1000);\n};\n\n/************************************\n jMoment Prototype\n ************************************/\n\nfunction fixFormat(format, _moment) {\n  var i = 5;\n  var replace = function (input) {\n    return _moment.localeData().longDateFormat(input) || input;\n  };\n  while (i > 0 && localFormattingTokens.test(format)) {\n    i -= 1;\n    format = format.replace(localFormattingTokens, replace);\n  }\n  return format;\n}\njMoment.fn.format = function (format) {\n  format = format || jMoment.defaultFormat;\n  if (format) {\n    if (isJalali(this)) {\n      format = toJalaliFormat(format);\n    }\n    format = fixFormat(format, this);\n    if (!formatFunctions[format]) {\n      formatFunctions[format] = makeFormatFunction(format);\n    }\n    format = formatFunctions[format](this);\n  }\n  var formatted = moment.fn.format.call(this, format);\n  return formatted;\n};\njMoment.fn.year = function (input) {\n  if (isJalali(this)) return jMoment.fn.jYear.call(this, input);else return moment.fn.year.call(this, input);\n};\njMoment.fn.jYear = function (input) {\n  var lastDay, j, g;\n  if (typeof input === \"number\") {\n    j = getJalaliOf(this);\n    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(input, j.jm));\n    g = toGregorian(input, j.jm, lastDay);\n    setDate(this, g.gy, g.gm, g.gd);\n    moment.updateOffset(this);\n    return this;\n  } else {\n    return getJalaliOf(this).jy;\n  }\n};\njMoment.fn.month = function (input) {\n  if (isJalali(this)) return jMoment.fn.jMonth.call(this, input);else return moment.fn.month.call(this, input);\n};\njMoment.fn.jMonth = function (input) {\n  var lastDay, j, g;\n  if (!isNull(input)) {\n    if (typeof input === \"string\") {\n      input = this.localeData().jMonthsParse(input);\n      if (typeof input !== \"number\") {\n        return this;\n      }\n    }\n    j = getJalaliOf(this);\n    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(j.jy, input));\n    this.jYear(j.jy + div(input, 12));\n    input = mod(input, 12);\n    if (input < 0) {\n      input += 12;\n      this.jYear(this.jYear() - 1);\n    }\n    g = toGregorian(this.jYear(), input, lastDay);\n    setDate(this, g.gy, g.gm, g.gd);\n    moment.updateOffset(this);\n    return this;\n  } else {\n    return getJalaliOf(this).jm;\n  }\n};\njMoment.fn.date = function (input) {\n  if (isJalali(this)) return jMoment.fn.jDate.call(this, input);else return moment.fn.date.call(this, input);\n};\nfunction getJalaliOf(momentObj) {\n  var d = momentObj._d;\n  if (momentObj._isUTC) {\n    return toJalali(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n  } else {\n    return toJalali(d.getFullYear(), d.getMonth(), d.getDate());\n  }\n}\njMoment.fn.jDate = function (input) {\n  var j, g;\n  if (typeof input === \"number\") {\n    j = getJalaliOf(this);\n    g = toGregorian(j.jy, j.jm, input);\n    setDate(this, g.gy, g.gm, g.gd);\n    moment.updateOffset(this);\n    return this;\n  } else {\n    return getJalaliOf(this).jd;\n  }\n};\njMoment.fn.jDay = function (input) {\n  if (typeof input === \"number\") {\n    return moment.fn.day.call(this, input - 1);\n  } else {\n    return (moment.fn.day.call(this) + 1) % 7;\n  }\n};\njMoment.fn.diff = function (input, unitOfTime, asFloat) {\n  //code taken and adjusted for jalali calendar from original moment diff module https://github.com/moment/moment/blob/develop/src/lib/moment/diff.js\n  if (!isJalali(this)) return moment.fn.diff.call(this, input, unitOfTime, asFloat);\n  var output;\n  switch (unitOfTime) {\n    case \"year\":\n      output = monthDiff(this, input) / 12;\n      break;\n    case \"month\":\n      output = monthDiff(this, input);\n      break;\n    case \"quarter\":\n      output = monthDiff(this, input) / 3;\n      break;\n    default:\n      output = moment.fn.diff.call(this, input, unitOfTime, asFloat);\n  }\n  return asFloat ? output : output < 0 ? Math.ceil(output) || 0 : Math.floor(output);\n  function monthDiff(a, b) {\n    if (a.date() < b.date()) {\n      // end-of-month calculations work correct when the start month has more\n      // days than the end month.\n      return -monthDiff(b, a);\n    }\n    // difference in months\n    var wholeMonthDiff = (b.jYear() - a.jYear()) * 12 + (b.jMonth() - a.jMonth()),\n      // b is in (anchor - 1 month, anchor + 1 month)\n      anchor = a.clone().add(wholeMonthDiff, \"months\"),\n      anchor2,\n      adjust;\n    if (b - anchor < 0) {\n      anchor2 = a.clone().add(wholeMonthDiff - 1, \"months\");\n      // linear across the month\n      adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n      anchor2 = a.clone().add(wholeMonthDiff + 1, \"months\");\n      // linear across the month\n      adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n  }\n};\njMoment.fn.dayOfYear = function (input) {\n  if (isJalali(this)) return jMoment.fn.jDayOfYear.call(this, input);else return moment.fn.dayOfYear.call(this, input);\n};\njMoment.fn.jDayOfYear = function (input) {\n  var dayOfYear = Math.round((jMoment(this).startOf(\"day\") - jMoment(this).startOf(\"jYear\")) / 864e5) + 1;\n  return isNull(input) ? dayOfYear : this.add(input - dayOfYear, \"d\");\n};\njMoment.fn.week = function (input) {\n  if (isJalali(this)) return jMoment.fn.jWeek.call(this, input);else return moment.fn.week.call(this, input);\n};\njMoment.fn.jWeek = function (input) {\n  var week = jWeekOfYear(this, 6, 12).week;\n  return isNull(input) ? week : this.add((input - week) * 7, \"d\");\n};\njMoment.fn.weekYear = function (input) {\n  if (isJalali(this)) return jMoment.fn.jWeekYear.call(this, input);else return moment.fn.weekYear.call(this, input);\n};\njMoment.fn.jWeekYear = function (input) {\n  var year = jWeekOfYear(this, 6, 12).year;\n  return isNull(input) ? year : this.add(input - year, \"jyear\");\n};\njMoment.fn.add = function (val, units) {\n  var temp;\n  if (!isNull(units) && !isNaN(+units)) {\n    temp = val;\n    val = units;\n    units = temp;\n  }\n  units = normalizeUnits(units, this);\n  if (units === 'jweek' || units === 'isoweek') {\n    units = 'week';\n  }\n  if (units === \"jyear\") {\n    this.jYear(this.jYear() + val);\n  } else if (units === \"jmonth\") {\n    this.jMonth(this.jMonth() + val);\n  } else {\n    moment.fn.add.call(this, val, units);\n  }\n  return this;\n};\njMoment.fn.subtract = function (val, units) {\n  var temp;\n  if (!isNull(units) && !isNaN(+units)) {\n    temp = val;\n    val = units;\n    units = temp;\n  }\n  units = normalizeUnits(units, this);\n  if (units === \"jyear\") {\n    this.jYear(this.jYear() - val);\n  } else if (units === \"jmonth\") {\n    this.jMonth(this.jMonth() - val);\n  } else {\n    moment.fn.subtract.call(this, val, units);\n  }\n  return this;\n};\njMoment.fn.startOf = function (units) {\n  var nunit = normalizeUnits(units, this);\n  if (nunit === \"jweek\") {\n    return this.startOf(\"day\").subtract(this.jDay(), \"day\");\n  }\n  if (nunit === \"jyear\") {\n    this.jMonth(0);\n    nunit = \"jmonth\";\n  }\n  if (nunit === \"jmonth\") {\n    this.jDate(1);\n    nunit = \"day\";\n  }\n  if (nunit === \"day\") {\n    this.hours(0);\n    this.minutes(0);\n    this.seconds(0);\n    this.milliseconds(0);\n    return this;\n  } else {\n    return moment.fn.startOf.call(this, units);\n  }\n};\njMoment.fn.endOf = function (units) {\n  units = normalizeUnits(units, this);\n  if (units === undefined || units === \"milisecond\") {\n    return this;\n  }\n  return this.startOf(units).add(1, units).subtract(1, \"ms\");\n};\njMoment.fn.isSame = function (other, units) {\n  units = normalizeUnits(units, this);\n  if (units === \"jyear\" || units === \"jmonth\") {\n    return moment.fn.isSame.call(this.clone().startOf(units), other.clone().startOf(units));\n  }\n  return moment.fn.isSame.call(this, other, units);\n};\njMoment.fn.isBefore = function (other, units) {\n  units = normalizeUnits(units, this);\n  if (units === \"jyear\" || units === \"jmonth\") {\n    return moment.fn.isBefore.call(this.clone().startOf(units), other.clone().startOf(units));\n  }\n  return moment.fn.isBefore.call(this, other, units);\n};\njMoment.fn.isAfter = function (other, units) {\n  units = normalizeUnits(units, this);\n  if (units === \"jyear\" || units === \"jmonth\") {\n    return moment.fn.isAfter.call(this.clone().startOf(units), other.clone().startOf(units));\n  }\n  return moment.fn.isAfter.call(this, other, units);\n};\njMoment.fn.clone = function () {\n  return jMoment(this);\n};\njMoment.fn.doAsJalali = function () {\n  this.calSystem = CalendarSystems.Jalali;\n  return this;\n};\njMoment.fn.doAsGregorian = function () {\n  this.calSystem = CalendarSystems.Gregorian;\n  return this;\n};\njMoment.fn.jYears = jMoment.fn.jYear;\njMoment.fn.jMonths = jMoment.fn.jMonth;\njMoment.fn.jDates = jMoment.fn.jDate;\njMoment.fn.jWeeks = jMoment.fn.jWeek;\njMoment.fn.daysInMonth = function () {\n  if (isJalali(this)) {\n    return this.jDaysInMonth();\n  }\n  return moment.fn.daysInMonth.call(this);\n};\njMoment.fn.jDaysInMonth = function () {\n  var month = this.jMonth();\n  var year = this.jYear();\n  if (month < 6) {\n    return 31;\n  } else if (month < 11) {\n    return 30;\n  } else if (jMoment.jIsLeapYear(year)) {\n    return 30;\n  } else {\n    return 29;\n  }\n};\njMoment.fn.isLeapYear = function () {\n  if (isJalali(this)) {\n    return this.jIsLeapYear();\n  }\n  return moment.fn.isLeapYear.call(this);\n};\njMoment.fn.jIsLeapYear = function () {\n  var year = this.jYear();\n  return isLeapJalaliYear(year);\n};\njMoment.fn.locale = function (locale) {\n  if (locale && moment.changeCalendarSystemByItsLocale) {\n    if (locale === \"fa\") {\n      this.doAsJalali();\n    } else {\n      this.doAsGregorian();\n    }\n  }\n  return moment.fn.locale.call(this, locale);\n};\n/************************************\n jMoment Statics\n ************************************/\njMoment.locale = function (locale, options) {\n  if (locale && moment.changeCalendarSystemByItsLocale) {\n    if (locale === \"fa\") {\n      this.useJalaliSystemPrimarily(options);\n    } else {\n      this.useJalaliSystemSecondary();\n    }\n  }\n  return moment.locale.call(this, locale);\n};\njMoment.from = function (date, locale, format) {\n  var lastLocale = jMoment.locale();\n  jMoment.locale(locale);\n  var m = jMoment(date, format);\n  m.locale(lastLocale);\n  jMoment.locale(lastLocale);\n  return m;\n};\njMoment.bindCalendarSystemAndLocale = function () {\n  moment.changeCalendarSystemByItsLocale = true;\n};\njMoment.unBindCalendarSystemAndLocale = function () {\n  moment.changeCalendarSystemByItsLocale = false;\n};\njMoment.useJalaliSystemPrimarily = function (options) {\n  moment.justUseJalali = true;\n  var useGregorianParser = false;\n  if (options) {\n    useGregorianParser = options.useGregorianParser;\n  }\n  moment.useGregorianParser = useGregorianParser;\n};\njMoment.useJalaliSystemSecondary = function () {\n  moment.justUseJalali = false;\n};\njMoment.jDaysInMonth = function (year, month) {\n  year += div(month, 12);\n  month = mod(month, 12);\n  if (month < 0) {\n    month += 12;\n    year -= 1;\n  }\n  if (month < 6) {\n    return 31;\n  } else if (month < 11) {\n    return 30;\n  } else if (jMoment.jIsLeapYear(year)) {\n    return 30;\n  } else {\n    return 29;\n  }\n};\njMoment.jIsLeapYear = isLeapJalaliYear;\nmoment.updateLocale(\"fa\", {\n  months: \"ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر\".split(\"_\"),\n  monthsShort: \"ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر\".split(\"_\"),\n  weekdays: \"یک\\u200cشنبه_دوشنبه_سه\\u200cشنبه_چهارشنبه_پنج\\u200cشنبه_جمعه_شنبه\".split(\"_\"),\n  weekdaysShort: \"یک\\u200cشنبه_دوشنبه_سه\\u200cشنبه_چهارشنبه_پنج\\u200cشنبه_جمعه_شنبه\".split(\"_\"),\n  weekdaysMin: \"ی_د_س_چ_پ_ج_ش\".split(\"_\"),\n  longDateFormat: {\n    LT: \"HH:mm\",\n    L: \"jYYYY/jMM/jDD\",\n    LL: \"jD jMMMM jYYYY\",\n    LLL: \"jD jMMMM jYYYY LT\",\n    LLLL: \"dddd، jD jMMMM jYYYY LT\"\n  },\n  calendar: {\n    sameDay: \"[امروز ساعت] LT\",\n    nextDay: \"[فردا ساعت] LT\",\n    nextWeek: \"dddd [ساعت] LT\",\n    lastDay: \"[دیروز ساعت] LT\",\n    lastWeek: \"dddd [ی پیش ساعت] LT\",\n    sameElse: \"L\"\n  },\n  relativeTime: {\n    future: \"در %s\",\n    past: \"%s پیش\",\n    s: \"چند ثانیه\",\n    m: \"1 دقیقه\",\n    mm: \"%d دقیقه\",\n    h: \"1 ساعت\",\n    hh: \"%d ساعت\",\n    d: \"1 روز\",\n    dd: \"%d روز\",\n    M: \"1 ماه\",\n    MM: \"%d ماه\",\n    y: \"1 سال\",\n    yy: \"%d سال\"\n  },\n  ordinal: \"%dم\",\n  preparse: function (string) {\n    return string;\n  },\n  postformat: function (string) {\n    return string;\n  },\n  week: {\n    dow: 6 // Saturday is the first day of the week.\n    ,\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n  },\n  meridiem: function (hour) {\n    return hour < 12 ? \"ق.ظ\" : \"ب.ظ\";\n  },\n  jMonths: \"فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند\".split(\"_\"),\n  jMonthsShort: \"فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند\".split(\"_\")\n});\njMoment.bindCalendarSystemAndLocale();\nmoment.locale(\"en\");\njMoment.jConvert = {\n  toJalali: toJalali,\n  toGregorian: toGregorian\n};\n\n/************************************\n Jalali Conversion\n ************************************/\n\nfunction toJalali(gy, gm, gd) {\n  var j = convertToJalali(gy, gm + 1, gd);\n  j.jm -= 1;\n  return j;\n}\nfunction toGregorian(jy, jm, jd) {\n  var g = convertToGregorian(jy, jm + 1, jd);\n  g.gm -= 1;\n  return g;\n}\n\n/*\n Utility helper functions.\n */\n\nfunction div(a, b) {\n  return ~~(a / b);\n}\nfunction mod(a, b) {\n  return a - ~~(a / b) * b;\n}\n\n/*\n Converts a Gregorian date to Jalali.\n */\nfunction convertToJalali(gy, gm, gd) {\n  if (Object.prototype.toString.call(gy) === \"[object Date]\") {\n    gd = gy.getDate();\n    gm = gy.getMonth() + 1;\n    gy = gy.getFullYear();\n  }\n  return d2j(g2d(gy, gm, gd));\n}\n\n/*\n Converts a Jalali date to Gregorian.\n */\nfunction convertToGregorian(jy, jm, jd) {\n  return d2g(j2d(jy, jm, jd));\n}\n\n/*\n Is this a leap year or not?\n */\nfunction isLeapJalaliYear(jy) {\n  return jalCal(jy).leap === 0;\n}\n\n/*\n This function determines if the Jalali (Persian) year is\n leap (366-day long) or is the common year (365 days), and\n finds the day in March (Gregorian calendar) of the first\n day of the Jalali year (jy).\n @param jy Jalali calendar year (-61 to 3177)\n @return\n leap: number of years since the last leap year (0 to 4)\n gy: Gregorian year of the beginning of Jalali year\n march: the March day of Farvardin the 1st (1st day of jy)\n @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm\n @see: http://www.fourmilab.ch/documents/calendar/\n */\nfunction jalCal(jy) {\n  // Jalali years starting the 33-year rule.\n  var breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178],\n    bl = breaks.length,\n    gy = jy + 621,\n    leapJ = -14,\n    jp = breaks[0],\n    jm,\n    jump,\n    leap,\n    leapG,\n    march,\n    n,\n    i;\n  if (jy < jp || jy >= breaks[bl - 1]) throw new Error(\"Invalid Jalali year \" + jy);\n\n  // Find the limiting years for the Jalali year jy.\n  for (i = 1; i < bl; i += 1) {\n    jm = breaks[i];\n    jump = jm - jp;\n    if (jy < jm) break;\n    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);\n    jp = jm;\n  }\n  n = jy - jp;\n\n  // Find the number of leap years from AD 621 to the beginning\n  // of the current Jalali year in the Persian calendar.\n  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);\n  if (mod(jump, 33) === 4 && jump - n === 4) leapJ += 1;\n\n  // And the same in the Gregorian calendar (until the year gy).\n  leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;\n\n  // Determine the Gregorian date of Farvardin the 1st.\n  march = 20 + leapJ - leapG;\n\n  // Find how many years have passed since the last leap year.\n  if (jump - n < 6) n = n - jump + div(jump + 4, 33) * 33;\n  leap = mod(mod(n + 1, 33) - 1, 4);\n  if (leap === -1) {\n    leap = 4;\n  }\n  return {\n    leap: leap,\n    gy: gy,\n    march: march\n  };\n}\n\n/*\n Converts a date of the Jalali calendar to the Julian Day number.\n @param jy Jalali year (1 to 3100)\n @param jm Jalali month (1 to 12)\n @param jd Jalali day (1 to 29/31)\n @return Julian Day number\n */\nfunction j2d(jy, jm, jd) {\n  var r = jalCal(jy);\n  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;\n}\n\n/*\n Converts the Julian Day number to a date in the Jalali calendar.\n @param jdn Julian Day number\n @return\n jy: Jalali year (1 to 3100)\n jm: Jalali month (1 to 12)\n jd: Jalali day (1 to 29/31)\n */\nfunction d2j(jdn) {\n  var gy = d2g(jdn).gy // Calculate Gregorian year (gy).\n    ,\n    jy = gy - 621,\n    r = jalCal(jy),\n    jdn1f = g2d(gy, 3, r.march),\n    jd,\n    jm,\n    k;\n\n  // Find number of days that passed since 1 Farvardin.\n  k = jdn - jdn1f;\n  if (k >= 0) {\n    if (k <= 185) {\n      // The first 6 months.\n      jm = 1 + div(k, 31);\n      jd = mod(k, 31) + 1;\n      return {\n        jy: jy,\n        jm: jm,\n        jd: jd\n      };\n    } else {\n      // The remaining months.\n      k -= 186;\n    }\n  } else {\n    // Previous Jalali year.\n    jy -= 1;\n    k += 179;\n    if (r.leap === 1) k += 1;\n  }\n  jm = 7 + div(k, 30);\n  jd = mod(k, 30) + 1;\n  return {\n    jy: jy,\n    jm: jm,\n    jd: jd\n  };\n}\n\n/*\n Calculates the Julian Day number from Gregorian or Julian\n calendar dates. This integer number corresponds to the noon of\n the date (i.e. 12 hours of Universal Time).\n The procedure was tested to be good since 1 March, -100100 (of both\n calendars) up to a few million years into the future.\n @param gy Calendar year (years BC numbered 0, -1, -2, ...)\n @param gm Calendar month (1 to 12)\n @param gd Calendar day of the month (1 to 28/29/30/31)\n @return Julian Day number\n */\nfunction g2d(gy, gm, gd) {\n  var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;\n  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;\n  return d;\n}\n\n/*\n Calculates Gregorian and Julian calendar dates from the Julian Day number\n (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both\n calendars) to some millions years ahead of the present.\n @param jdn Julian Day number\n @return\n gy: Calendar year (years BC numbered 0, -1, -2, ...)\n gm: Calendar month (1 to 12)\n gd: Calendar day of the month M (1 to 28/29/30/31)\n */\nfunction d2g(jdn) {\n  var j, i, gd, gm, gy;\n  j = 4 * jdn + 139361631;\n  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;\n  i = div(mod(j, 1461), 4) * 5 + 308;\n  gd = div(mod(i, 153), 5) + 1;\n  gm = mod(div(i, 153), 12) + 1;\n  gy = div(j, 1461) - 100100 + div(8 - gm, 6);\n  return {\n    gy: gy,\n    gm: gm,\n    gd: gd\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamFsYWxpLW1vbWVudC9qYWxhbGktbW9tZW50LmpzIiwibWFwcGluZ3MiOiJBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2ovLi9ub2RlX21vZHVsZXMvamFsYWxpLW1vbWVudC9qYWxhbGktbW9tZW50LmpzPzZhZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IGpNb21lbnQ7XG5cbnZhciBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50L21vbWVudFwiKTtcbnJlcXVpcmUoXCJtb21lbnQvbG9jYWxlL2ZhXCIpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29uc3RhbnRzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpP2ooTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98d1tvfHddP3xZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3wpfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFNTP1M/fFh8eno/fFpaP3wuKS9nXG4gICAgLCBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFR8TEw/TD9MP3xsezEsNH0pL2dcbiAgICAsIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cyA9IC9cXGRcXGQ/L1xuICAgICwgcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHMgPSAvXFxkezEsM30vXG4gICAgLCBwYXJzZVRva2VuVGhyZWVEaWdpdHMgPSAvXFxkezN9L1xuICAgICwgcGFyc2VUb2tlbkZvdXJEaWdpdHMgPSAvXFxkezEsNH0vXG4gICAgLCBwYXJzZVRva2VuU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7MSw2fS9cbiAgICAsIHBhcnNlVG9rZW5Xb3JkID0gL1swLTldKltcImEtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pXG4gICAgLCBwYXJzZVRva2VuVGltZXpvbmUgPSAvWnxbXFwrXFwtXVxcZFxcZDo/XFxkXFxkL2lcbiAgICAsIHBhcnNlVG9rZW5UID0gL1QvaVxuICAgICwgcGFyc2VUb2tlblRpbWVzdGFtcE1zID0gL1tcXCtcXC1dP1xcZCsoXFwuXFxkezEsM30pPy9cblxuICAgICwgdW5pdEFsaWFzZXMgPSB7XG4gICAgICAgIGptOiBcImptb250aFwiXG4gICAgICAgICwgam1vbnRoczogXCJqbW9udGhcIlxuICAgICAgICAsIGp5OiBcImp5ZWFyXCJcbiAgICAgICAgLCBqeWVhcnM6IFwianllYXJcIlxuICAgIH1cblxuICAgICwgZm9ybWF0RnVuY3Rpb25zID0ge31cblxuICAgICwgb3JkaW5hbGl6ZVRva2VucyA9IFwiREREIHcgTSBEXCIuc3BsaXQoXCIgXCIpXG4gICAgLCBwYWRkZWRUb2tlbnMgPSBcIk0gRCB3XCIuc3BsaXQoXCIgXCIpO1xuXG52YXIgQ2FsZW5kYXJTeXN0ZW1zID0ge1xuICAgIEphbGFsaTogMSxcbiAgICBHcmVnb3JpYW46IDIsXG59XG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7XG4gICAgak06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuak1vbnRoKCkgKyAxO1xuICAgIH0sXG4gICAgak1NTTogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuak1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSxcbiAgICBqTU1NTTogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuak1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0sXG4gICAgakQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakRhdGUoKTtcbiAgICB9LFxuICAgIGpEREQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakRheU9mWWVhcigpO1xuICAgIH0sXG4gICAganc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMualdlZWsoKTtcbiAgICB9LFxuICAgIGpZWTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMualllYXIoKSAlIDEwMCwgMik7XG4gICAgfSxcbiAgICBqWVlZWTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMualllYXIoKSwgNCk7XG4gICAgfSxcbiAgICBqWVlZWVk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmpZZWFyKCksIDUpO1xuICAgIH0sXG4gICAgamdnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5qV2Vla1llYXIoKSAlIDEwMCwgMik7XG4gICAgfSxcbiAgICBqZ2dnZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qV2Vla1llYXIoKTtcbiAgICB9LFxuICAgIGpnZ2dnZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMualdlZWtZZWFyKCksIDUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhZFRva2VuKGZ1bmMsIGNvdW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwoZnVuYy5jYWxsKHRoaXMsIGEpLCBjb3VudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9yZGluYWxpemVUb2tlbihmdW5jLCBwZXJpb2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5jYWxsKHRoaXMsIGEpLCBwZXJpb2QpO1xuICAgIH07XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgd2hpbGUgKG9yZGluYWxpemVUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBvcmRpbmFsaXplVG9rZW5zLnBvcCgpO1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tcImpcIiArIGkgKyBcIm9cIl0gPSBvcmRpbmFsaXplVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbXCJqXCIgKyBpXSwgaSk7XG4gICAgfVxuICAgIHdoaWxlIChwYWRkZWRUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBwYWRkZWRUb2tlbnMucG9wKCk7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW1wialwiICsgaSArIGldID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbXCJqXCIgKyBpXSwgMik7XG4gICAgfVxuICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zLmpEREREID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnMuakRERCwgMyk7XG59KCkpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gSGVscGVyc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIGIpXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogcmV0dXJuIGEgc3RyaW5nIHdoaWNoIGxlbmd0aCBpcyBhcyBtdWNoIGFzIHlvdSBuZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIGlucHV0XG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0TGVuZ3RoIGV4cGVjdGVkIGxlbmd0aFxuICogQGV4YW1wbGUgbGVmdFplcm9GaWxsKDUsMikgPT4gMDVcbiAqKi9cbmZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICAgIHZhciBvdXRwdXQgPSBudW1iZXIgKyBcIlwiO1xuICAgIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKXtcbiAgICAgICAgb3V0cHV0ID0gXCIwXCIgKyBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogZGV0ZXJtaW5lIG9iamVjdCBpcyBhcnJheSBvciBub3RcbiAqIEBwYXJhbSBpbnB1dFxuICoqL1xuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG59XG5cbi8qKlxuICogQ2hhbmdlcyBhbnkgbW9tZW50IEdyZWdvcmlhbiBmb3JtYXQgdG8gSmFsYWxpIHN5c3RlbSBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXRcbiAqIEBleGFtcGxlIHRvSmFsYWxpRm9ybWF0KFwiWVlZWS9NTU0vRERcIikgPT4gXCJqWVlZWS9qTU1NL2pERFwiXG4gKiovXG5mdW5jdGlvbiB0b0phbGFsaUZvcm1hdChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZighaSB8fCAoZm9ybWF0W2ktMV0gIT09IFwialwiICYmIGZvcm1hdFtpLTFdICE9PSBmb3JtYXRbaV0pKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0W2ldID09PSBcIllcIiB8fCBmb3JtYXRbaV0gPT09IFwiTVwiIHx8IGZvcm1hdFtpXSA9PT0gXCJEXCIgfHwgZm9ybWF0W2ldID09PSBcImdcIikge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgwLCBpKSArIFwialwiICsgZm9ybWF0LnNsaWNlKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXQ7XG59XG5cbi8qKlxuICogQ2hhbmdlcyBhbnkgbW9tZW50IEdyZWdvcmlhbiB1bml0cyB0byBKYWxhbGkgc3lzdGVtIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdHNcbiAqIEBleGFtcGxlIHRvSmFsYWxpVW5pdChcIllZWVkvTU1NL0REXCIpID0+IFwiallZWVkvak1NTS9qRERcIlxuICoqL1xuZnVuY3Rpb24gdG9KYWxhbGlVbml0KHVuaXRzKSB7XG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlIFwid2Vla1wiIDogcmV0dXJuIFwialdlZWtcIjtcbiAgICAgICAgY2FzZSBcInllYXJcIiA6IHJldHVybiBcImpZZWFyXCI7XG4gICAgICAgIGNhc2UgXCJtb250aFwiIDogcmV0dXJuIFwiak1vbnRoXCI7XG4gICAgICAgIGNhc2UgXCJtb250aHNcIiA6IHJldHVybiBcImpNb250aHNcIjtcbiAgICAgICAgY2FzZSBcIm1vbnRoTmFtZVwiIDogcmV0dXJuIFwiak1vbnRoc1Nob3J0XCI7XG4gICAgICAgIGNhc2UgXCJtb250aHNTaG9ydFwiIDogcmV0dXJuIFwiak1vbnRoc1Nob3J0XCI7XG4gICAgfVxuICAgIHJldHVybiB1bml0cztcbn1cblxuLyoqXG4gKiBub3JtYWxpemUgdW5pdHMgdG8gYmUgY29tcGFyYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IHVuaXRzXG4gKiovXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cywgbW9tZW50T2JqKSB7XG4gICAgaWYgKGlzSmFsYWxpKG1vbWVudE9iaikpIHtcbiAgICAgICAgdW5pdHMgPSB0b0phbGFsaVVuaXQodW5pdHMpO1xuICAgIH1cbiAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgIHZhciBsb3dlcmVkID0gdW5pdHMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyZWQuc3RhcnRzV2l0aCgnaicpKSB1bml0cyA9IHVuaXRBbGlhc2VzW2xvd2VyZWRdIHx8IGxvd2VyZWQ7XG4gICAgICAgIC8vIFRPRE8gOiBhZGQgdW5pdCB0ZXN0XG4gICAgICAgIGlmICh1bml0cyA9PT0gXCJqZGF5XCIpIHVuaXRzID0gXCJkYXlcIjtcbiAgICAgICAgZWxzZSBpZiAodW5pdHMgPT09IFwiamRcIikgdW5pdHMgPSBcImRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXRzO1xufVxuXG4vKipcbiAqIHNldCBhIGdyZWdvcmlhbiBkYXRlIHRvIG1vbWVudCBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb21lbnRJbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHllYXIgaW4gZ3JlZ29yaWFuIHN5c3RlbVxuICogQHBhcmFtIHtzdHJpbmd9IG1vbnRoIGluIGdyZWdvcmlhbiBzeXN0ZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXkgaW4gZ3JlZ29yaWFuIHN5c3RlbVxuICoqL1xuZnVuY3Rpb24gc2V0RGF0ZShtb21lbnRJbnN0YW5jZSwgeWVhciwgbW9udGgsIGRheSkge1xuICAgIHZhciBkID0gbW9tZW50SW5zdGFuY2UuX2Q7XG4gICAgaWYgKG1vbWVudEluc3RhbmNlLl9pc1VUQykge1xuICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5ldy1jYXAqL1xuICAgICAgICBtb21lbnRJbnN0YW5jZS5fZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksXG4gICAgICAgICAgICBkLmdldFVUQ0hvdXJzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaWxsaXNlY29uZHMoKSkpO1xuICAgICAgICAvKmVzbGludC1lbmFibGUgbmV3LWNhcCovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9tZW50SW5zdGFuY2UuX2QgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuICAgICAgICAgICAgZC5nZXRIb3VycygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlKHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgIEYucHJvdG90eXBlID0gcGFyZW50O1xuICAgIHJldHVybiBuZXcgRigpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcIlwiLl9fcHJvdG9fXyl7XG4gICAgICAgIHJldHVybiBvYmplY3QuX19wcm90b19fO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICByZXR1cm4gb2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBMYW5ndWFnZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHRlbmQoZ2V0UHJvdG90eXBlT2YobW9tZW50LmxvY2FsZURhdGEoKSksXG4gICAgeyBfak1vbnRoczogWyBcIkZhcnZhcmRpblwiXG4gICAgICAgICwgXCJPcmRpYmVoZXNodFwiXG4gICAgICAgICwgXCJLaG9yZGFhZFwiXG4gICAgICAgICwgXCJUaXJcIlxuICAgICAgICAsIFwiTW9yZGFhZFwiXG4gICAgICAgICwgXCJTaGFocml2YXJcIlxuICAgICAgICAsIFwiTWVoclwiXG4gICAgICAgICwgXCJBYWJhYW5cIlxuICAgICAgICAsIFwiQWF6YXJcIlxuICAgICAgICAsIFwiRGV5XCJcbiAgICAgICAgLCBcIkJhaG1hblwiXG4gICAgICAgICwgXCJFc2ZhbmRcIlxuICAgIF1cbiAgICAgICAgLCBqTW9udGhzOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fak1vbnRoc1ttLmpNb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pNb250aHM7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgICAgICwgX2pNb250aHNTaG9ydDogIFsgXCJGYXJcIlxuICAgICAgICAsIFwiT3JkXCJcbiAgICAgICAgLCBcIktob1wiXG4gICAgICAgICwgXCJUaXJcIlxuICAgICAgICAsIFwiQW1vXCJcbiAgICAgICAgLCBcIlNoYVwiXG4gICAgICAgICwgXCJNZWhcIlxuICAgICAgICAsIFwiQWFiXCJcbiAgICAgICAgLCBcIkFhelwiXG4gICAgICAgICwgXCJEZXlcIlxuICAgICAgICAsIFwiQmFoXCJcbiAgICAgICAgLCBcIkVzZlwiXG4gICAgXVxuICAgICAgICAsIGpNb250aHNTaG9ydDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qTW9udGhzU2hvcnRbbS5qTW9udGgoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fak1vbnRoc1Nob3J0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgICAgICwgak1vbnRoc1BhcnNlOiBmdW5jdGlvbiAobW9udGhOYW1lKSB7XG4gICAgICAgIHZhciBpXG4gICAgICAgICAgICAsIG1vbVxuICAgICAgICAgICAgLCByZWdleDtcbiAgICAgICAgaWYgKCF0aGlzLl9qTW9udGhzUGFyc2Upe1xuICAgICAgICAgICAgdGhpcy5fak1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpICs9IDEpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvblwidCBoYXZlIGl0IGFscmVhZHkuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2pNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGpNb21lbnQoWzIwMDAsICgyICsgaSkgJSAxMiwgMjVdKTtcbiAgICAgICAgICAgICAgICByZWdleCA9IFwiXlwiICsgdGhpcy5qTW9udGhzKG1vbSwgXCJcIikgKyBcInxeXCIgKyB0aGlzLmpNb250aHNTaG9ydChtb20sIFwiXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZShcIi5cIiwgXCJcIiksIFwiaVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRlc3QgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2pNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIH1cbik7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBGb3JtYXR0aW5nXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoXG4gICAgICAgICwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSl7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pe1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSl7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IFwiW1wiICsgYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgKyBcIl1cIiA6IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIFBhcnNpbmdcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlIFwiakRERERcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGhyZWVEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJqWVlZWVwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Gb3VyRGlnaXRzO1xuICAgICAgICBjYXNlIFwiallZWVlZXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblNpeERpZ2l0cztcbiAgICAgICAgY2FzZSBcImpERERcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSBcImpNTU1cIjpcbiAgICAgICAgY2FzZSBcImpNTU1NXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbldvcmQ7XG4gICAgICAgIGNhc2UgXCJqTU1cIjpcbiAgICAgICAgY2FzZSBcImpERFwiOlxuICAgICAgICBjYXNlIFwiallZXCI6XG4gICAgICAgIGNhc2UgXCJqTVwiOlxuICAgICAgICBjYXNlIFwiakRcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lT3JUd29EaWdpdHM7XG4gICAgICAgIGNhc2UgXCJEREREXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xuICAgICAgICBjYXNlIFwiWVlZWVwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Gb3VyRGlnaXRzO1xuICAgICAgICBjYXNlIFwiWVlZWVlcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuU2l4RGlnaXRzO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICBjYXNlIFwiU1NcIjpcbiAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICBjYXNlIFwiREREXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgIGNhc2UgXCJkZGRcIjpcbiAgICAgICAgY2FzZSBcImRkZGRcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuV29yZDtcbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQubG9jYWxlRGF0YShjb25maWcuX2wpLl9tZXJpZGllbVBhcnNlO1xuICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaW1lc3RhbXBNcztcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWV6b25lO1xuICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UO1xuICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgY2FzZSBcIkREXCI6XG4gICAgICAgIGNhc2UgXCJZWVwiOlxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lT3JUd29EaWdpdHM7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh0b2tlbi5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOdWxsKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlID09PSBudWxsIHx8IHZhcmlhYmxlID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgIHZhciBhXG4gICAgICAgICwgZGF0ZVBhcnRBcnJheSA9IGNvbmZpZy5fYTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBcImpNXCI6XG4gICAgICAgIGNhc2UgXCJqTU1cIjpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbMV0gPSBpc051bGwoaW5wdXQpPyAwIDogfn5pbnB1dCAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImpNTU1cIjpcbiAgICAgICAgY2FzZSBcImpNTU1NXCI6XG4gICAgICAgICAgICBhID0gbW9tZW50LmxvY2FsZURhdGEoY29uZmlnLl9sKS5qTW9udGhzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFpc051bGwoYSkpe1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbMV0gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiakRcIjpcbiAgICAgICAgY2FzZSBcImpERFwiOlxuICAgICAgICBjYXNlIFwiakRERFwiOlxuICAgICAgICBjYXNlIFwiakRERERcIjpcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGlucHV0KSl7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVsyXSA9IH5+aW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImpZWVwiOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVswXSA9IH5+aW5wdXQgKyAofn5pbnB1dCA+IDQ3ID8gMTMwMCA6IDE0MDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJqWVlZWVwiOlxuICAgICAgICBjYXNlIFwiallZWVlZXCI6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5WzBdID0gfn5pbnB1dDtcbiAgICB9XG4gICAgaWYgKGlzTnVsbChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXRlRnJvbUFycmF5KGNvbmZpZykge1xuICAgIHZhciBnXG4gICAgICAgICwgalxuICAgICAgICAsIGp5ID0gY29uZmlnLl9hWzBdXG4gICAgICAgICwgam0gPSBjb25maWcuX2FbMV1cbiAgICAgICAgLCBqZCA9IGNvbmZpZy5fYVsyXTtcblxuICAgIGlmIChpc051bGwoankpICYmIGlzTnVsbChqbSkgJiYgaXNOdWxsKGpkKSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgankgPSAhaXNOdWxsKGp5KSA/IGp5IDogMDtcbiAgICBqbSA9ICFpc051bGwoam0pID8gam0gOiAwO1xuICAgIGpkID0gIWlzTnVsbChqZCkgPyBqZCA6IDE7XG4gICAgaWYgKGpkIDwgMSB8fCBqZCA+IGpNb21lbnQuakRheXNJbk1vbnRoKGp5LCBqbSkgfHwgam0gPCAwIHx8IGptID4gMTEpe1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZyA9IHRvR3JlZ29yaWFuKGp5LCBqbSwgamQpO1xuICAgIGogPSB0b0phbGFsaShnLmd5LCBnLmdtLCBnLmdkKTtcbiAgICBjb25maWcuX2pEaWZmID0gMDtcbiAgICBpZiAofn5qLmp5ICE9PSBqeSl7XG4gICAgICAgIGNvbmZpZy5fakRpZmYgKz0gMTtcbiAgICB9XG4gICAgaWYgKH5+ai5qbSAhPT0gam0pe1xuICAgICAgICBjb25maWcuX2pEaWZmICs9IDE7XG4gICAgfVxuICAgIGlmICh+fmouamQgIT09IGpkKXtcbiAgICAgICAgY29uZmlnLl9qRGlmZiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gW2cuZ3ksIGcuZ20sIGcuZ2RdO1xufVxuXG5mdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgdmFyIHRva2VucyA9IGNvbmZpZy5fZi5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAsIHN0cmluZyA9IGNvbmZpZy5faSArIFwiXCJcbiAgICAgICAgLCBsZW4gPSB0b2tlbnMubGVuZ3RoXG4gICAgICAgICwgaVxuICAgICAgICAsIHRva2VuXG4gICAgICAgICwgcGFyc2VkSW5wdXQ7XG5cbiAgICBjb25maWcuX2EgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpLmV4ZWMoc3RyaW5nKSB8fCBbXSlbMF07XG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCl7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKXtcbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RyaW5nKXtcbiAgICAgICAgY29uZmlnLl9pbCA9IHN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVGcm9tQXJyYXkoY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnLCB1dGMpIHtcbiAgICB2YXIgbGVuID0gY29uZmlnLl9mLmxlbmd0aFxuICAgICAgICAsIGlcbiAgICAgICAgLCBmb3JtYXRcbiAgICAgICAgLCB0ZW1wTW9tZW50XG4gICAgICAgICwgYmVzdE1vbWVudFxuICAgICAgICAsIGN1cnJlbnRTY29yZVxuICAgICAgICAsIHNjb3JlVG9CZWF0O1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vbWVudChuZXcgRGF0ZShOYU4pKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mW2ldO1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wTW9tZW50ID0gbWFrZU1vbWVudChjb25maWcuX2ksIGZvcm1hdCwgY29uZmlnLl9sLCBjb25maWcuX3N0cmljdCwgdXRjKTtcblxuICAgICAgICBpZiAoIXRlbXBNb21lbnQuaXNWYWxpZCgpKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VycmVudFNjb3JlID0gY29tcGFyZUFycmF5cyh0ZW1wTW9tZW50Ll9hLCB0ZW1wTW9tZW50LnRvQXJyYXkoKSlcbiAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBNb21lbnQuX2pEaWZmO1xuICAgICAgICBpZiAodGVtcE1vbWVudC5faWwpe1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBNb21lbnQuX2lsLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsKHNjb3JlVG9CZWF0KSB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcE1vbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0TW9tZW50O1xufVxuXG5mdW5jdGlvbiByZW1vdmVQYXJzZWRUb2tlbnMoY29uZmlnKSB7XG4gICAgdmFyIHN0cmluZyA9IGNvbmZpZy5faSArIFwiXCJcbiAgICAgICAgLCBpbnB1dCA9IFwiXCJcbiAgICAgICAgLCBmb3JtYXQgPSBcIlwiXG4gICAgICAgICwgYXJyYXkgPSBjb25maWcuX2YubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcbiAgICAgICAgLCBsZW4gPSBhcnJheS5sZW5ndGhcbiAgICAgICAgLCBpXG4gICAgICAgICwgbWF0Y2hcbiAgICAgICAgLCBwYXJzZWQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbWF0Y2ggPSBhcnJheVtpXTtcbiAgICAgICAgcGFyc2VkID0gKGdldFBhcnNlUmVnZXhGb3JUb2tlbihtYXRjaCwgY29uZmlnKS5leGVjKHN0cmluZykgfHwgW10pWzBdO1xuICAgICAgICBpZiAocGFyc2VkKXtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWQpICsgcGFyc2VkLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZm9ybWF0VG9rZW5GdW5jdGlvbnNbbWF0Y2hdIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICBmb3JtYXQgKz0gbWF0Y2g7XG4gICAgICAgICAgICBpZiAocGFyc2VkKXtcbiAgICAgICAgICAgICAgICBpbnB1dCArPSBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnLl9pID0gaW5wdXQ7XG4gICAgY29uZmlnLl9mID0gZm9ybWF0O1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gV2VlayBvZiBZZWFyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBqV2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgIHZhciBlbmQgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIGZpcnN0RGF5T2ZXZWVrXG4gICAgICAgICwgZGF5c1RvRGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBtb20uZGF5KClcbiAgICAgICAgLCBhZGp1c3RlZE1vbWVudDtcblxuICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPiBlbmQpIHtcbiAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgfVxuICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgIGRheXNUb0RheU9mV2VlayArPSA3O1xuICAgIH1cbiAgICBhZGp1c3RlZE1vbWVudCA9IGpNb21lbnQobW9tKS5hZGQoZGF5c1RvRGF5T2ZXZWVrLCBcImRcIik7XG4gICAgcmV0dXJuICB7IHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5qRGF5T2ZZZWFyKCkgLyA3KVxuICAgICAgICAsIHllYXI6IGFkanVzdGVkTW9tZW50LmpZZWFyKClcbiAgICB9O1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gVG9wIExldmVsIEZ1bmN0aW9uc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmZ1bmN0aW9uIGlzSmFsYWxpIChtb21lbnRPYmopIHtcbiAgICByZXR1cm4gbW9tZW50T2JqICYmXG4gICAgICAgIChtb21lbnRPYmouY2FsU3lzdGVtID09PSBDYWxlbmRhclN5c3RlbXMuSmFsYWxpKSB8fFxuICAgICAgICAobW9tZW50Lmp1c3RVc2VKYWxhbGkgJiYgbW9tZW50T2JqLmNhbFN5c3RlbSAhPT0gQ2FsZW5kYXJTeXN0ZW1zLkdyZWdvcmlhbik7XG59XG5mdW5jdGlvbiBpc0lucHV0SmFsYWxpKGZvcm1hdCwgbW9tZW50T2JqLCBpbnB1dCkge1xuICAgIHJldHVybiAobW9tZW50Lmp1c3RVc2VKYWxhbGkgfHwgKG1vbWVudE9iaiAmJiBtb21lbnRPYmouY2FsU3lzdGVtID09PSBDYWxlbmRhclN5c3RlbXMuSmFsYWxpKSlcbn1cbmZ1bmN0aW9uIG1ha2VNb21lbnQoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0LCB1dGMpIHtcbiAgICBpZiAodHlwZW9mIGxhbmcgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHV0YyA9IHV0YyB8fCBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IGxhbmc7XG4gICAgICAgIGxhbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChtb21lbnQuSVNPXzg2MDEgPT09IGZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJztcbiAgICB9XG4gICAgY29uc3QgaW5wdXRJc0phbGFsaSA9IGlzSW5wdXRKYWxhbGkoZm9ybWF0LCB0aGlzLCBpbnB1dCk7XG4gICAgLy8gdmFyIGl0c0phbGFsaURhdGUgPSAoaXNKYWxhbGkodGhpcykpO1xuICAgIGlmKGlucHV0ICYmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpICYmICFmb3JtYXQgJiYgaW5wdXRJc0phbGFsaSAmJiAhbW9tZW50LnVzZUdyZWdvcmlhblBhcnNlcikge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xcLy9nLFwiLVwiKTtcbiAgICAgICAgaWYoL1xcZHs0fVxcLVxcZHsyfVxcLVxcZHsyfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktak1NLWpERFwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGR7NH1cXC1cXGR7Mn1cXC1cXGR7MX0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZLWpNTS1qRFwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGR7NH1cXC1cXGR7MX1cXC1cXGR7MX0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZLWpNLWpEXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcLVxcZHsxfVxcLVxcZHsyfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktak0takREXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcLVdcXGR7Mn1cXC1cXGR7Mn0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZLWpXLWpERFwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGR7NH1cXC1cXGR7M30vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZLWpERERcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFxkezh9Ly50ZXN0KGlucHV0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJqWVlZWWpNTWpERFwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGR7NH1XXFxkezJ9XFxkezF9Ly50ZXN0KGlucHV0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJqWVlZWWpXV2pEXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVdcXGR7Mn0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZaldXXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcZHszfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVlqREREXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcm1hdCAmJiBpbnB1dElzSmFsYWxpKXtcbiAgICAgICAgZm9ybWF0ID0gdG9KYWxhbGlGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCAmJiB0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgZm9ybWF0ID0gZml4Rm9ybWF0KGZvcm1hdCwgbW9tZW50KTtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID1cbiAgICAgICAgeyBfaTogaW5wdXRcbiAgICAgICAgICAgICwgX2Y6IGZvcm1hdFxuICAgICAgICAgICAgLCBfbDogbGFuZ1xuICAgICAgICAgICAgLCBfc3RyaWN0OiBzdHJpY3RcbiAgICAgICAgICAgICwgX2lzVVRDOiB1dGNcbiAgICAgICAgfVxuICAgICAgICAsIGRhdGVcbiAgICAgICAgLCBtXG4gICAgICAgICwgam1cbiAgICAgICAgLCBvcmlnSW5wdXQgPSBpbnB1dFxuICAgICAgICAsIG9yaWdGb3JtYXQgPSBmb3JtYXQ7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnLCB1dGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgICAgcmVtb3ZlUGFyc2VkVG9rZW5zKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiWVlZWS1NTS1ERC1cIiArIGNvbmZpZy5fZjtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGxlZnRaZXJvRmlsbChkYXRlWzBdLCA0KSArIFwiLVwiXG4gICAgICAgICAgICAgICAgICAgICsgbGVmdFplcm9GaWxsKGRhdGVbMV0gKyAxLCAyKSArIFwiLVwiXG4gICAgICAgICAgICAgICAgICAgICsgbGVmdFplcm9GaWxsKGRhdGVbMl0sIDIpICsgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgKyBjb25maWcuX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHV0Yyl7XG4gICAgICAgIG0gPSBtb21lbnQudXRjKGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIG0gPSBtb21lbnQoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UgfHwgKGlucHV0ICYmIGlucHV0Ll9pc0FNb21lbnRPYmplY3QgJiYgIWlucHV0Ll9pc1ZhbGlkKSl7XG4gICAgICAgIG0uX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbS5fakRpZmYgPSBjb25maWcuX2pEaWZmIHx8IDA7XG4gICAgam0gPSBvYmplY3RDcmVhdGUoak1vbWVudC5mbik7XG4gICAgZXh0ZW5kKGptLCBtKTtcbiAgICBpZiAoc3RyaWN0ICYmIGptLmlzVmFsaWQoKSkge1xuICAgICAgICBqbS5faXNWYWxpZCA9IGptLmZvcm1hdChvcmlnRm9ybWF0KSA9PT0gb3JpZ0lucHV0O1xuICAgIH1cbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQuY2FsU3lzdGVtKSB7XG4gICAgICAgIGptLmNhbFN5c3RlbSA9IGlucHV0LmNhbFN5c3RlbTtcbiAgICB9XG4gICAgcmV0dXJuIGptO1xufVxuXG5mdW5jdGlvbiBqTW9tZW50KGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCkge1xuICAgIHJldHVybiBtYWtlTW9tZW50KGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCwgZmFsc2UpO1xufVxuXG5leHRlbmQoak1vbWVudCwgbW9tZW50KTtcbmpNb21lbnQuZm4gPSBvYmplY3RDcmVhdGUobW9tZW50LmZuKTtcblxuak1vbWVudC51dGMgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KSB7XG4gICAgcmV0dXJuIG1ha2VNb21lbnQoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0LCB0cnVlKTtcbn07XG5cbmpNb21lbnQudW5peCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBtYWtlTW9tZW50KGlucHV0ICogMTAwMCk7XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gak1vbWVudCBQcm90b3R5cGVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGZpeEZvcm1hdChmb3JtYXQsIF9tb21lbnQpIHtcbiAgICB2YXIgaSA9IDU7XG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9tb21lbnQubG9jYWxlRGF0YSgpLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICB9O1xuICAgIHdoaWxlIChpID4gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxuak1vbWVudC5mbi5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdGZvcm1hdCA9IGZvcm1hdCB8fCBqTW9tZW50LmRlZmF1bHRGb3JtYXQ7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICBpZiAoaXNKYWxhbGkodGhpcykpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHRvSmFsYWxpRm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gZml4Rm9ybWF0KGZvcm1hdCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSkge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlZCA9IG1vbWVudC5mbi5mb3JtYXQuY2FsbCh0aGlzLCBmb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXR0ZWQ7XG59O1xuXG5qTW9tZW50LmZuLnllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaXNKYWxhbGkodGhpcykpIHJldHVybiBqTW9tZW50LmZuLmpZZWFyLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLnllYXIuY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuak1vbWVudC5mbi5qWWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBsYXN0RGF5XG4gICAgICAgICwgalxuICAgICAgICAsIGc7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBqID0gZ2V0SmFsYWxpT2YodGhpcyk7XG4gICAgICAgIGxhc3REYXkgPSBNYXRoLm1pbihqLmpkLCBqTW9tZW50LmpEYXlzSW5Nb250aChpbnB1dCwgai5qbSkpO1xuICAgICAgICBnID0gdG9HcmVnb3JpYW4oaW5wdXQsIGouam0sIGxhc3REYXkpO1xuICAgICAgICBzZXREYXRlKHRoaXMsIGcuZ3ksIGcuZ20sIGcuZ2QpO1xuICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0SmFsYWxpT2YodGhpcykuank7XG4gICAgfVxufTtcblxuak1vbWVudC5mbi5tb250aCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpc0phbGFsaSh0aGlzKSkgcmV0dXJuIGpNb21lbnQuZm4uak1vbnRoLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLm1vbnRoLmNhbGwodGhpcywgaW5wdXQpO1xufTtcbmpNb21lbnQuZm4uak1vbnRoID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGxhc3REYXlcbiAgICAgICAgLCBqXG4gICAgICAgICwgZztcbiAgICBpZiAoIWlzTnVsbChpbnB1dCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmxvY2FsZURhdGEoKS5qTW9udGhzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaiA9IGdldEphbGFsaU9mKHRoaXMpO1xuICAgICAgICBsYXN0RGF5ID0gTWF0aC5taW4oai5qZCwgak1vbWVudC5qRGF5c0luTW9udGgoai5qeSwgaW5wdXQpKTtcbiAgICAgICAgdGhpcy5qWWVhcihqLmp5ICsgZGl2KGlucHV0LCAxMikpO1xuICAgICAgICBpbnB1dCA9IG1vZChpbnB1dCwgMTIpO1xuICAgICAgICBpZiAoaW5wdXQgPCAwKSB7XG4gICAgICAgICAgICBpbnB1dCArPSAxMjtcbiAgICAgICAgICAgIHRoaXMualllYXIodGhpcy5qWWVhcigpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZyA9IHRvR3JlZ29yaWFuKHRoaXMualllYXIoKSwgaW5wdXQsIGxhc3REYXkpO1xuICAgICAgICBzZXREYXRlKHRoaXMsIGcuZ3ksIGcuZ20sIGcuZ2QpO1xuICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0SmFsYWxpT2YodGhpcykuam07XG4gICAgfVxufTtcblxuak1vbWVudC5mbi5kYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSByZXR1cm4gak1vbWVudC5mbi5qRGF0ZS5jYWxsKHRoaXMsaW5wdXQpO1xuICAgIGVsc2UgcmV0dXJuIG1vbWVudC5mbi5kYXRlLmNhbGwodGhpcywgaW5wdXQpO1xufTtcbmZ1bmN0aW9uIGdldEphbGFsaU9mIChtb21lbnRPYmopIHtcbiAgICB2YXIgZCA9IG1vbWVudE9iai5fZDtcbiAgICBpZiAobW9tZW50T2JqLl9pc1VUQykge1xuICAgICAgICByZXR1cm4gdG9KYWxhbGkoZC5nZXRVVENGdWxsWWVhcigpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9KYWxhbGkoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcbiAgICB9XG59XG5qTW9tZW50LmZuLmpEYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGpcbiAgICAgICAgLCBnO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaiA9IGdldEphbGFsaU9mKHRoaXMpO1xuICAgICAgICBnID0gdG9HcmVnb3JpYW4oai5qeSwgai5qbSwgaW5wdXQpO1xuICAgICAgICBzZXREYXRlKHRoaXMsIGcuZ3ksIGcuZ20sIGcuZ2QpO1xuICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0SmFsYWxpT2YodGhpcykuamQ7XG4gICAgfVxufTtcblxuak1vbWVudC5mbi5qRGF5ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbW9tZW50LmZuLmRheS5jYWxsKHRoaXMsIGlucHV0IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChtb21lbnQuZm4uZGF5LmNhbGwodGhpcykgKyAxKSAlIDc7XG4gICAgfVxufTtcbmpNb21lbnQuZm4uZGlmZiA9IGZ1bmN0aW9uIChpbnB1dCwgdW5pdE9mVGltZSwgYXNGbG9hdCkge1xuICAgIC8vY29kZSB0YWtlbiBhbmQgYWRqdXN0ZWQgZm9yIGphbGFsaSBjYWxlbmRhciBmcm9tIG9yaWdpbmFsIG1vbWVudCBkaWZmIG1vZHVsZSBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9ibG9iL2RldmVsb3Avc3JjL2xpYi9tb21lbnQvZGlmZi5qc1xuICAgIGlmICghaXNKYWxhbGkodGhpcykpXG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uZGlmZi5jYWxsKHRoaXMsIGlucHV0LCB1bml0T2ZUaW1lLCBhc0Zsb2F0KTtcblxuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoICh1bml0T2ZUaW1lKSB7XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgaW5wdXQpIC8gMTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJxdWFydGVyXCI6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgaW5wdXQpIC8gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3V0cHV0ID0gbW9tZW50LmZuLmRpZmYuY2FsbCh0aGlzLCBpbnB1dCwgdW5pdE9mVGltZSwgYXNGbG9hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiAob3V0cHV0IDwgMCA/IE1hdGguY2VpbChvdXRwdXQpIHx8IDAgOiBNYXRoLmZsb29yKG91dHB1dCkpO1xuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLmpZZWFyKCkgLSBhLmpZZWFyKCkpICogMTIgKyAoYi5qTW9udGgoKSAtIGEuak1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsIFwibW9udGhzXCIpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdFxuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCBcIm1vbnRoc1wiKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsIFwibW9udGhzXCIpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxufVxuXG5qTW9tZW50LmZuLmRheU9mWWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpc0phbGFsaSh0aGlzKSkgcmV0dXJuIGpNb21lbnQuZm4uakRheU9mWWVhci5jYWxsKHRoaXMsaW5wdXQpO1xuICAgIGVsc2UgcmV0dXJuIG1vbWVudC5mbi5kYXlPZlllYXIuY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuak1vbWVudC5mbi5qRGF5T2ZZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKGpNb21lbnQodGhpcykuc3RhcnRPZihcImRheVwiKSAtIGpNb21lbnQodGhpcykuc3RhcnRPZihcImpZZWFyXCIpKSAvIDg2NGU1KSArIDE7XG4gICAgcmV0dXJuIGlzTnVsbChpbnB1dCkgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgXCJkXCIpO1xufTtcblxuak1vbWVudC5mbi53ZWVrID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSByZXR1cm4gak1vbWVudC5mbi5qV2Vlay5jYWxsKHRoaXMsaW5wdXQpO1xuICAgIGVsc2UgcmV0dXJuIG1vbWVudC5mbi53ZWVrLmNhbGwodGhpcywgaW5wdXQpO1xufTtcbmpNb21lbnQuZm4ualdlZWsgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IGpXZWVrT2ZZZWFyKHRoaXMsIDYsIDEyKS53ZWVrO1xuICAgIHJldHVybiBpc051bGwoaW5wdXQpID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgXCJkXCIpO1xufTtcblxuak1vbWVudC5mbi53ZWVrWWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpc0phbGFsaSh0aGlzKSkgcmV0dXJuIGpNb21lbnQuZm4ualdlZWtZZWFyLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLndlZWtZZWFyLmNhbGwodGhpcywgaW5wdXQpO1xufTtcbmpNb21lbnQuZm4ualdlZWtZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHllYXIgPSBqV2Vla09mWWVhcih0aGlzLCA2LCAxMikueWVhcjtcbiAgICByZXR1cm4gaXNOdWxsKGlucHV0KSA/IHllYXIgOiB0aGlzLmFkZChpbnB1dCAtIHllYXIsIFwianllYXJcIik7XG59O1xuXG5qTW9tZW50LmZuLmFkZCA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG4gICAgdmFyIHRlbXA7XG4gICAgaWYgKCFpc051bGwodW5pdHMpICYmICFpc05hTigrdW5pdHMpKSB7XG4gICAgICAgIHRlbXAgPSB2YWw7XG4gICAgICAgIHZhbCA9IHVuaXRzO1xuICAgICAgICB1bml0cyA9IHRlbXA7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMsIHRoaXMpO1xuICAgIGlmICh1bml0cyA9PT0gJ2p3ZWVrJyB8fCB1bml0cz09PSdpc293ZWVrJykgeyB1bml0cyA9ICd3ZWVrJyB9XG4gICAgaWYgKHVuaXRzID09PSBcImp5ZWFyXCIpIHtcbiAgICAgICAgdGhpcy5qWWVhcih0aGlzLmpZZWFyKCkgKyB2YWwpO1xuICAgIH0gZWxzZSBpZiAodW5pdHMgPT09IFwiam1vbnRoXCIpIHtcbiAgICAgICAgdGhpcy5qTW9udGgodGhpcy5qTW9udGgoKSArIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9tZW50LmZuLmFkZC5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmpNb21lbnQuZm4uc3VidHJhY3QgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuICAgIHZhciB0ZW1wO1xuICAgIGlmICghaXNOdWxsKHVuaXRzKSAmJiAhaXNOYU4oK3VuaXRzKSkge1xuICAgICAgICB0ZW1wID0gdmFsO1xuICAgICAgICB2YWwgPSB1bml0cztcbiAgICAgICAgdW5pdHMgPSB0ZW1wO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCB0aGlzKTtcbiAgICBpZiAodW5pdHMgPT09IFwianllYXJcIikge1xuICAgICAgICB0aGlzLmpZZWFyKHRoaXMualllYXIoKSAtIHZhbCk7XG4gICAgfSBlbHNlIGlmICh1bml0cyA9PT0gXCJqbW9udGhcIikge1xuICAgICAgICB0aGlzLmpNb250aCh0aGlzLmpNb250aCgpIC0gdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb21lbnQuZm4uc3VidHJhY3QuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5qTW9tZW50LmZuLnN0YXJ0T2YgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICB2YXIgbnVuaXQgPSBub3JtYWxpemVVbml0cyh1bml0cywgdGhpcyk7XG4gICAgaWYoIG51bml0ID09PSBcImp3ZWVrXCIpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKFwiZGF5XCIpLnN1YnRyYWN0KHRoaXMuakRheSgpICwgXCJkYXlcIik7XG4gICAgfVxuICAgIGlmIChudW5pdCA9PT0gXCJqeWVhclwiKSB7XG4gICAgICAgIHRoaXMuak1vbnRoKDApO1xuICAgICAgICBudW5pdCA9IFwiam1vbnRoXCI7XG4gICAgfVxuICAgIGlmIChudW5pdCA9PT0gXCJqbW9udGhcIikge1xuICAgICAgICB0aGlzLmpEYXRlKDEpO1xuICAgICAgICBudW5pdCA9IFwiZGF5XCI7XG4gICAgfVxuICAgIGlmIChudW5pdCA9PT0gXCJkYXlcIikge1xuICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uc3RhcnRPZi5jYWxsKHRoaXMsIHVuaXRzKTtcbiAgICB9XG59O1xuXG5qTW9tZW50LmZuLmVuZE9mID0gZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cywgdGhpcyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09IFwibWlsaXNlY29uZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgdW5pdHMpLnN1YnRyYWN0KDEsIFwibXNcIik7XG59O1xuXG5qTW9tZW50LmZuLmlzU2FtZSA9IGZ1bmN0aW9uIChvdGhlciwgdW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCB0aGlzKTtcbiAgICBpZiAodW5pdHMgPT09IFwianllYXJcIiB8fCB1bml0cyA9PT0gXCJqbW9udGhcIikge1xuICAgICAgICByZXR1cm4gbW9tZW50LmZuLmlzU2FtZS5jYWxsKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSwgb3RoZXIuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4uaXNTYW1lLmNhbGwodGhpcywgb3RoZXIsIHVuaXRzKTtcbn07XG5cbmpNb21lbnQuZm4uaXNCZWZvcmUgPSBmdW5jdGlvbiAob3RoZXIsIHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cywgdGhpcyk7XG4gICAgaWYgKHVuaXRzID09PSBcImp5ZWFyXCIgfHwgdW5pdHMgPT09IFwiam1vbnRoXCIpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5pc0JlZm9yZS5jYWxsKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSwgb3RoZXIuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4uaXNCZWZvcmUuY2FsbCh0aGlzLCBvdGhlciwgdW5pdHMpO1xufTtcblxuak1vbWVudC5mbi5pc0FmdGVyID0gZnVuY3Rpb24gKG90aGVyLCB1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMsIHRoaXMpO1xuICAgIGlmICh1bml0cyA9PT0gXCJqeWVhclwiIHx8IHVuaXRzID09PSBcImptb250aFwiKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uaXNBZnRlci5jYWxsKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSwgb3RoZXIuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4uaXNBZnRlci5jYWxsKHRoaXMsIG90aGVyLCB1bml0cyk7XG59O1xuXG5qTW9tZW50LmZuLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBqTW9tZW50KHRoaXMpO1xufTtcblxuak1vbWVudC5mbi5kb0FzSmFsYWxpID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsU3lzdGVtID0gQ2FsZW5kYXJTeXN0ZW1zLkphbGFsaTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5qTW9tZW50LmZuLmRvQXNHcmVnb3JpYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxTeXN0ZW0gPSBDYWxlbmRhclN5c3RlbXMuR3JlZ29yaWFuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuak1vbWVudC5mbi5qWWVhcnMgPSBqTW9tZW50LmZuLmpZZWFyO1xuak1vbWVudC5mbi5qTW9udGhzID0gak1vbWVudC5mbi5qTW9udGg7XG5qTW9tZW50LmZuLmpEYXRlcyA9IGpNb21lbnQuZm4uakRhdGU7XG5qTW9tZW50LmZuLmpXZWVrcyA9IGpNb21lbnQuZm4ualdlZWs7XG5cbmpNb21lbnQuZm4uZGF5c0luTW9udGggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaXNKYWxhbGkodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakRheXNJbk1vbnRoKCk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4uZGF5c0luTW9udGguY2FsbCh0aGlzKTtcbn07XG5qTW9tZW50LmZuLmpEYXlzSW5Nb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9udGggPSB0aGlzLmpNb250aCgpO1xuICAgIHZhciB5ZWFyID0gdGhpcy5qWWVhcigpO1xuICAgIGlmIChtb250aCA8IDYpIHtcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH0gZWxzZSBpZiAobW9udGggPCAxMSkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfSBlbHNlIGlmIChqTW9tZW50LmpJc0xlYXBZZWFyKHllYXIpKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMjk7XG4gICAgfVxufTtcblxuak1vbWVudC5mbi5pc0xlYXBZZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpJc0xlYXBZZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4uaXNMZWFwWWVhci5jYWxsKHRoaXMpO1xufTtcbmpNb21lbnQuZm4uaklzTGVhcFllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHllYXIgPSB0aGlzLmpZZWFyKCk7XG4gICAgcmV0dXJuIGlzTGVhcEphbGFsaVllYXIoeWVhcik7XG59O1xuak1vbWVudC5mbi5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICBpZiAobG9jYWxlICYmIG1vbWVudC5jaGFuZ2VDYWxlbmRhclN5c3RlbUJ5SXRzTG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUgPT09IFwiZmFcIikge1xuICAgICAgICAgICAgdGhpcy5kb0FzSmFsYWxpKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvQXNHcmVnb3JpYW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9tZW50LmZuLmxvY2FsZS5jYWxsKHRoaXMsIGxvY2FsZSk7XG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIGpNb21lbnQgU3RhdGljc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmpNb21lbnQubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvY2FsZSAmJiBtb21lbnQuY2hhbmdlQ2FsZW5kYXJTeXN0ZW1CeUl0c0xvY2FsZSkge1xuICAgICAgICBpZiAobG9jYWxlID09PSBcImZhXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlSmFsYWxpU3lzdGVtUHJpbWFyaWx5KG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VKYWxhbGlTeXN0ZW1TZWNvbmRhcnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9tZW50LmxvY2FsZS5jYWxsKHRoaXMsIGxvY2FsZSk7XG59O1xuXG5qTW9tZW50LmZyb20gPSBmdW5jdGlvbihkYXRlLCBsb2NhbGUsIGZvcm1hdCkge1xuICAgIHZhciBsYXN0TG9jYWxlID0gak1vbWVudC5sb2NhbGUoKTtcbiAgICBqTW9tZW50LmxvY2FsZShsb2NhbGUpO1xuICAgIHZhciBtID0gak1vbWVudChkYXRlLCBmb3JtYXQpO1xuICAgIG0ubG9jYWxlKGxhc3RMb2NhbGUpO1xuICAgIGpNb21lbnQubG9jYWxlKGxhc3RMb2NhbGUpO1xuICAgIHJldHVybiBtO1xufTtcblxuak1vbWVudC5iaW5kQ2FsZW5kYXJTeXN0ZW1BbmRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbW9tZW50LmNoYW5nZUNhbGVuZGFyU3lzdGVtQnlJdHNMb2NhbGUgPSB0cnVlO1xufTtcbmpNb21lbnQudW5CaW5kQ2FsZW5kYXJTeXN0ZW1BbmRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbW9tZW50LmNoYW5nZUNhbGVuZGFyU3lzdGVtQnlJdHNMb2NhbGUgPSBmYWxzZTtcbn07XG5cbmpNb21lbnQudXNlSmFsYWxpU3lzdGVtUHJpbWFyaWx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBtb21lbnQuanVzdFVzZUphbGFsaSA9IHRydWU7XG4gICAgdmFyIHVzZUdyZWdvcmlhblBhcnNlciA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHVzZUdyZWdvcmlhblBhcnNlciA9IG9wdGlvbnMudXNlR3JlZ29yaWFuUGFyc2VyO1xuICAgIH1cbiAgICBtb21lbnQudXNlR3JlZ29yaWFuUGFyc2VyID0gdXNlR3JlZ29yaWFuUGFyc2VyO1xufTtcbmpNb21lbnQudXNlSmFsYWxpU3lzdGVtU2Vjb25kYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIG1vbWVudC5qdXN0VXNlSmFsYWxpID0gZmFsc2U7XG59O1xuXG5qTW9tZW50LmpEYXlzSW5Nb250aCA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgIHllYXIgKz0gZGl2KG1vbnRoLCAxMik7XG4gICAgbW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICBpZiAobW9udGggPCAwKSB7XG4gICAgICAgIG1vbnRoICs9IDEyO1xuICAgICAgICB5ZWFyIC09IDE7XG4gICAgfVxuICAgIGlmIChtb250aCA8IDYpIHtcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH0gZWxzZSBpZiAobW9udGggPCAxMSkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfSBlbHNlIGlmIChqTW9tZW50LmpJc0xlYXBZZWFyKHllYXIpKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMjk7XG4gICAgfVxufTtcblxuak1vbWVudC5qSXNMZWFwWWVhciA9IGlzTGVhcEphbGFsaVllYXI7XG5cbm1vbWVudC51cGRhdGVMb2NhbGUoXCJmYVwiLCB7XG4gICAgICAgIG1vbnRoczogKFwi2pjYp9mG2YjbjNmHX9mB2YjYsduM2Ydf2YXYp9ix2LNf2KLZiNix24zZhF/ZhdmHX9qY2YjYptmGX9qY2YjYptuM2Ydf2KfZiNiqX9iz2b7Yqtin2YXYqNixX9in2qnYqtio2LFf2YbZiNin2YXYqNixX9iv2LPYp9mF2KjYsVwiKS5zcGxpdChcIl9cIilcbiAgICAgICAgLCBtb250aHNTaG9ydDogKFwi2pjYp9mG2YjbjNmHX9mB2YjYsduM2Ydf2YXYp9ix2LNf2KLZiNix24zZhF/ZhdmHX9qY2YjYptmGX9qY2YjYptuM2Ydf2KfZiNiqX9iz2b7Yqtin2YXYqNixX9in2qnYqtio2LFf2YbZiNin2YXYqNixX9iv2LPYp9mF2KjYsVwiKS5zcGxpdChcIl9cIilcbiAgICAgICAgLCB3ZWVrZGF5czogKFwi24zaqVxcdTIwMGPYtNmG2KjZh1/Yr9mI2LTZhtio2Ydf2LPZh1xcdTIwMGPYtNmG2KjZh1/ahtmH2KfYsdi02YbYqNmHX9m+2YbYrFxcdTIwMGPYtNmG2KjZh1/YrNmF2LnZh1/YtNmG2KjZh1wiKS5zcGxpdChcIl9cIilcbiAgICAgICAgLCB3ZWVrZGF5c1Nob3J0OiAoXCLbjNqpXFx1MjAwY9i02YbYqNmHX9iv2YjYtNmG2KjZh1/Ys9mHXFx1MjAwY9i02YbYqNmHX9qG2YfYp9ix2LTZhtio2Ydf2b7ZhtisXFx1MjAwY9i02YbYqNmHX9is2YXYudmHX9i02YbYqNmHXCIpLnNwbGl0KFwiX1wiKVxuICAgICAgICAsIHdlZWtkYXlzTWluOiBcItuMX9ivX9izX9qGX9m+X9isX9i0XCIuc3BsaXQoXCJfXCIpXG4gICAgICAgICwgbG9uZ0RhdGVGb3JtYXQ6XG4gICAgICAgICAgICB7IExUOiBcIkhIOm1tXCJcbiAgICAgICAgICAgICAgICAsIEw6IFwiallZWVkvak1NL2pERFwiXG4gICAgICAgICAgICAgICAgLCBMTDogXCJqRCBqTU1NTSBqWVlZWVwiXG4gICAgICAgICAgICAgICAgLCBMTEw6IFwiakQgak1NTU0gallZWVkgTFRcIlxuICAgICAgICAgICAgICAgICwgTExMTDogXCJkZGRk2IwgakQgak1NTU0gallZWVkgTFRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAsIGNhbGVuZGFyOlxuICAgICAgICAgICAgeyBzYW1lRGF5OiBcIlvYp9mF2LHZiNiyINiz2KfYudiqXSBMVFwiXG4gICAgICAgICAgICAgICAgLCBuZXh0RGF5OiBcIlvZgdix2K/YpyDYs9in2LnYql0gTFRcIlxuICAgICAgICAgICAgICAgICwgbmV4dFdlZWs6IFwiZGRkZCBb2LPYp9i52KpdIExUXCJcbiAgICAgICAgICAgICAgICAsIGxhc3REYXk6IFwiW9iv24zYsdmI2LIg2LPYp9i52KpdIExUXCJcbiAgICAgICAgICAgICAgICAsIGxhc3RXZWVrOiBcImRkZGQgW9uMINm+24zYtCDYs9in2LnYql0gTFRcIlxuICAgICAgICAgICAgICAgICwgc2FtZUVsc2U6IFwiTFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICwgcmVsYXRpdmVUaW1lOlxuICAgICAgICAgICAgeyBmdXR1cmU6IFwi2K/YsSAlc1wiXG4gICAgICAgICAgICAgICAgLCBwYXN0OiBcIiVzINm+24zYtFwiXG4gICAgICAgICAgICAgICAgLCBzOiBcItqG2YbYryDYq9in2YbbjNmHXCJcbiAgICAgICAgICAgICAgICAsIG06IFwiMSDYr9mC24zZgtmHXCJcbiAgICAgICAgICAgICAgICAsIG1tOiBcIiVkINiv2YLbjNmC2YdcIlxuICAgICAgICAgICAgICAgICwgaDogXCIxINiz2KfYudiqXCJcbiAgICAgICAgICAgICAgICAsIGhoOiBcIiVkINiz2KfYudiqXCJcbiAgICAgICAgICAgICAgICAsIGQ6IFwiMSDYsdmI2LJcIlxuICAgICAgICAgICAgICAgICwgZGQ6IFwiJWQg2LHZiNiyXCJcbiAgICAgICAgICAgICAgICAsIE06IFwiMSDZhdin2YdcIlxuICAgICAgICAgICAgICAgICwgTU06IFwiJWQg2YXYp9mHXCJcbiAgICAgICAgICAgICAgICAsIHk6IFwiMSDYs9in2YRcIlxuICAgICAgICAgICAgICAgICwgeXk6IFwiJWQg2LPYp9mEXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgLCBvcmRpbmFsOiBcIiVk2YVcIixcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLCB3ZWVrOlxuICAgICAgICAgICAgeyBkb3c6IDYgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgICAgICAsIGRveTogMTIgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICAgICAgfVxuICAgICAgICAsIG1lcmlkaWVtOiBmdW5jdGlvbiAoaG91cikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCAxMiA/IFwi2YIu2LhcIiA6IFwi2Kgu2LhcIjtcbiAgICAgICAgfVxuICAgICAgICAsIGpNb250aHM6IChcItmB2LHZiNix2K/bjNmGX9in2LHYr9uM2KjZh9i02Kpf2K7Ysdiv2KfYr1/YqtuM2LFf2YXYsdiv2KfYr1/YtNmH2LHbjNmI2LFf2YXZh9ixX9ii2KjYp9mGX9ii2LDYsV/Yr9uMX9io2YfZhdmGX9in2LPZgdmG2K9cIikuc3BsaXQoXCJfXCIpXG4gICAgICAgICwgak1vbnRoc1Nob3J0OiBcItmB2LHZiNix2K/bjNmGX9in2LHYr9uM2KjZh9i02Kpf2K7Ysdiv2KfYr1/YqtuM2LFf2YXYsdiv2KfYr1/YtNmH2LHbjNmI2LFf2YXZh9ixX9ii2KjYp9mGX9ii2LDYsV/Yr9uMX9io2YfZhdmGX9in2LPZgdmG2K9cIi5zcGxpdChcIl9cIilcbiAgICB9KTtcbmpNb21lbnQuYmluZENhbGVuZGFyU3lzdGVtQW5kTG9jYWxlKCk7XG5tb21lbnQubG9jYWxlKFwiZW5cIik7XG5cbmpNb21lbnQuakNvbnZlcnQgPSAgeyB0b0phbGFsaTogdG9KYWxhbGlcbiAgICAsIHRvR3JlZ29yaWFuOiB0b0dyZWdvcmlhblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIEphbGFsaSBDb252ZXJzaW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiB0b0phbGFsaShneSwgZ20sIGdkKSB7XG4gICAgdmFyIGogPSBjb252ZXJ0VG9KYWxhbGkoZ3ksIGdtICsgMSwgZ2QpO1xuICAgIGouam0gLT0gMTtcbiAgICByZXR1cm4gajtcbn1cblxuZnVuY3Rpb24gdG9HcmVnb3JpYW4oanksIGptLCBqZCkge1xuICAgIHZhciBnID0gY29udmVydFRvR3JlZ29yaWFuKGp5LCBqbSArIDEsIGpkKTtcbiAgICBnLmdtIC09IDE7XG4gICAgcmV0dXJuIGc7XG59XG5cbi8qXG4gVXRpbGl0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICovXG5cbmZ1bmN0aW9uIGRpdihhLCBiKSB7XG4gICAgcmV0dXJuIH5+KGEgLyBiKTtcbn1cblxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIH5+KGEgLyBiKSAqIGI7XG59XG5cbi8qXG4gQ29udmVydHMgYSBHcmVnb3JpYW4gZGF0ZSB0byBKYWxhbGkuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0phbGFsaShneSwgZ20sIGdkKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChneSkgPT09IFwiW29iamVjdCBEYXRlXVwiKSB7XG4gICAgICAgIGdkID0gZ3kuZ2V0RGF0ZSgpO1xuICAgICAgICBnbSA9IGd5LmdldE1vbnRoKCkgKyAxO1xuICAgICAgICBneSA9IGd5LmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBkMmooZzJkKGd5LCBnbSwgZ2QpKTtcbn1cblxuLypcbiBDb252ZXJ0cyBhIEphbGFsaSBkYXRlIHRvIEdyZWdvcmlhbi5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvR3JlZ29yaWFuKGp5LCBqbSwgamQpIHtcbiAgICByZXR1cm4gZDJnKGoyZChqeSwgam0sIGpkKSk7XG59XG5cbi8qXG4gSXMgdGhpcyBhIGxlYXAgeWVhciBvciBub3Q/XG4gKi9cbmZ1bmN0aW9uIGlzTGVhcEphbGFsaVllYXIoankpIHtcbiAgICByZXR1cm4gamFsQ2FsKGp5KS5sZWFwID09PSAwO1xufVxuXG4vKlxuIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiB0aGUgSmFsYWxpIChQZXJzaWFuKSB5ZWFyIGlzXG4gbGVhcCAoMzY2LWRheSBsb25nKSBvciBpcyB0aGUgY29tbW9uIHllYXIgKDM2NSBkYXlzKSwgYW5kXG4gZmluZHMgdGhlIGRheSBpbiBNYXJjaCAoR3JlZ29yaWFuIGNhbGVuZGFyKSBvZiB0aGUgZmlyc3RcbiBkYXkgb2YgdGhlIEphbGFsaSB5ZWFyIChqeSkuXG4gQHBhcmFtIGp5IEphbGFsaSBjYWxlbmRhciB5ZWFyICgtNjEgdG8gMzE3NylcbiBAcmV0dXJuXG4gbGVhcDogbnVtYmVyIG9mIHllYXJzIHNpbmNlIHRoZSBsYXN0IGxlYXAgeWVhciAoMCB0byA0KVxuIGd5OiBHcmVnb3JpYW4geWVhciBvZiB0aGUgYmVnaW5uaW5nIG9mIEphbGFsaSB5ZWFyXG4gbWFyY2g6IHRoZSBNYXJjaCBkYXkgb2YgRmFydmFyZGluIHRoZSAxc3QgKDFzdCBkYXkgb2YgankpXG4gQHNlZTogaHR0cDovL3d3dy5hc3Ryby51bmkudG9ydW4ucGwvfmtiL1BhcGVycy9FTVAvUGVyc2lhbkMtRU1QLmh0bVxuIEBzZWU6IGh0dHA6Ly93d3cuZm91cm1pbGFiLmNoL2RvY3VtZW50cy9jYWxlbmRhci9cbiAqL1xuZnVuY3Rpb24gamFsQ2FsKGp5KSB7XG4gICAgLy8gSmFsYWxpIHllYXJzIHN0YXJ0aW5nIHRoZSAzMy15ZWFyIHJ1bGUuXG4gICAgdmFyIGJyZWFrcyA9ICBbIC02MSwgOSwgMzgsIDE5OSwgNDI2LCA2ODYsIDc1NiwgODE4LCAxMTExLCAxMTgxLCAxMjEwXG4gICAgICAgICwgMTYzNSwgMjA2MCwgMjA5NywgMjE5MiwgMjI2MiwgMjMyNCwgMjM5NCwgMjQ1NiwgMzE3OFxuICAgIF1cbiAgICAgICAgLCBibCA9IGJyZWFrcy5sZW5ndGhcbiAgICAgICAgLCBneSA9IGp5ICsgNjIxXG4gICAgICAgICwgbGVhcEogPSAtMTRcbiAgICAgICAgLCBqcCA9IGJyZWFrc1swXVxuICAgICAgICAsIGptXG4gICAgICAgICwganVtcFxuICAgICAgICAsIGxlYXBcbiAgICAgICAgLCBsZWFwR1xuICAgICAgICAsIG1hcmNoXG4gICAgICAgICwgblxuICAgICAgICAsIGk7XG5cbiAgICBpZiAoankgPCBqcCB8fCBqeSA+PSBicmVha3NbYmwgLSAxXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKYWxhbGkgeWVhciBcIiArIGp5KTtcblxuICAgIC8vIEZpbmQgdGhlIGxpbWl0aW5nIHllYXJzIGZvciB0aGUgSmFsYWxpIHllYXIgankuXG4gICAgZm9yIChpID0gMTsgaSA8IGJsOyBpICs9IDEpIHtcbiAgICAgICAgam0gPSBicmVha3NbaV07XG4gICAgICAgIGp1bXAgPSBqbSAtIGpwO1xuICAgICAgICBpZiAoankgPCBqbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZWFwSiA9IGxlYXBKICsgZGl2KGp1bXAsIDMzKSAqIDggKyBkaXYobW9kKGp1bXAsIDMzKSwgNCk7XG4gICAgICAgIGpwID0gam07XG4gICAgfVxuICAgIG4gPSBqeSAtIGpwO1xuXG4gICAgLy8gRmluZCB0aGUgbnVtYmVyIG9mIGxlYXAgeWVhcnMgZnJvbSBBRCA2MjEgdG8gdGhlIGJlZ2lubmluZ1xuICAgIC8vIG9mIHRoZSBjdXJyZW50IEphbGFsaSB5ZWFyIGluIHRoZSBQZXJzaWFuIGNhbGVuZGFyLlxuICAgIGxlYXBKID0gbGVhcEogKyBkaXYobiwgMzMpICogOCArIGRpdihtb2QobiwgMzMpICsgMywgNCk7XG4gICAgaWYgKG1vZChqdW1wLCAzMykgPT09IDQgJiYganVtcCAtIG4gPT09IDQpXG4gICAgICAgIGxlYXBKICs9IDE7XG5cbiAgICAvLyBBbmQgdGhlIHNhbWUgaW4gdGhlIEdyZWdvcmlhbiBjYWxlbmRhciAodW50aWwgdGhlIHllYXIgZ3kpLlxuICAgIGxlYXBHID0gZGl2KGd5LCA0KSAtIGRpdigoZGl2KGd5LCAxMDApICsgMSkgKiAzLCA0KSAtIDE1MDtcblxuICAgIC8vIERldGVybWluZSB0aGUgR3JlZ29yaWFuIGRhdGUgb2YgRmFydmFyZGluIHRoZSAxc3QuXG4gICAgbWFyY2ggPSAyMCArIGxlYXBKIC0gbGVhcEc7XG5cbiAgICAvLyBGaW5kIGhvdyBtYW55IHllYXJzIGhhdmUgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IGxlYXAgeWVhci5cbiAgICBpZiAoanVtcCAtIG4gPCA2KVxuICAgICAgICBuID0gbiAtIGp1bXAgKyBkaXYoanVtcCArIDQsIDMzKSAqIDMzO1xuICAgIGxlYXAgPSBtb2QobW9kKG4gKyAxLCAzMykgLSAxLCA0KTtcbiAgICBpZiAobGVhcCA9PT0gLTEpIHtcbiAgICAgICAgbGVhcCA9IDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICB7IGxlYXA6IGxlYXBcbiAgICAgICAgLCBneTogZ3lcbiAgICAgICAgLCBtYXJjaDogbWFyY2hcbiAgICB9O1xufVxuXG4vKlxuIENvbnZlcnRzIGEgZGF0ZSBvZiB0aGUgSmFsYWxpIGNhbGVuZGFyIHRvIHRoZSBKdWxpYW4gRGF5IG51bWJlci5cbiBAcGFyYW0gankgSmFsYWxpIHllYXIgKDEgdG8gMzEwMClcbiBAcGFyYW0gam0gSmFsYWxpIG1vbnRoICgxIHRvIDEyKVxuIEBwYXJhbSBqZCBKYWxhbGkgZGF5ICgxIHRvIDI5LzMxKVxuIEByZXR1cm4gSnVsaWFuIERheSBudW1iZXJcbiAqL1xuZnVuY3Rpb24gajJkKGp5LCBqbSwgamQpIHtcbiAgICB2YXIgciA9IGphbENhbChqeSk7XG4gICAgcmV0dXJuIGcyZChyLmd5LCAzLCByLm1hcmNoKSArIChqbSAtIDEpICogMzEgLSBkaXYoam0sIDcpICogKGptIC0gNykgKyBqZCAtIDE7XG59XG5cbi8qXG4gQ29udmVydHMgdGhlIEp1bGlhbiBEYXkgbnVtYmVyIHRvIGEgZGF0ZSBpbiB0aGUgSmFsYWxpIGNhbGVuZGFyLlxuIEBwYXJhbSBqZG4gSnVsaWFuIERheSBudW1iZXJcbiBAcmV0dXJuXG4gank6IEphbGFsaSB5ZWFyICgxIHRvIDMxMDApXG4gam06IEphbGFsaSBtb250aCAoMSB0byAxMilcbiBqZDogSmFsYWxpIGRheSAoMSB0byAyOS8zMSlcbiAqL1xuZnVuY3Rpb24gZDJqKGpkbikge1xuICAgIHZhciBneSA9IGQyZyhqZG4pLmd5IC8vIENhbGN1bGF0ZSBHcmVnb3JpYW4geWVhciAoZ3kpLlxuICAgICAgICAsIGp5ID0gZ3kgLSA2MjFcbiAgICAgICAgLCByID0gamFsQ2FsKGp5KVxuICAgICAgICAsIGpkbjFmID0gZzJkKGd5LCAzLCByLm1hcmNoKVxuICAgICAgICAsIGpkXG4gICAgICAgICwgam1cbiAgICAgICAgLCBrO1xuXG4gICAgLy8gRmluZCBudW1iZXIgb2YgZGF5cyB0aGF0IHBhc3NlZCBzaW5jZSAxIEZhcnZhcmRpbi5cbiAgICBrID0gamRuIC0gamRuMWY7XG4gICAgaWYgKGsgPj0gMCkge1xuICAgICAgICBpZiAoayA8PSAxODUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCA2IG1vbnRocy5cbiAgICAgICAgICAgIGptID0gMSArIGRpdihrLCAzMSk7XG4gICAgICAgICAgICBqZCA9IG1vZChrLCAzMSkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuICB7IGp5OiBqeVxuICAgICAgICAgICAgICAgICwgam06IGptXG4gICAgICAgICAgICAgICAgLCBqZDogamRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIG1vbnRocy5cbiAgICAgICAgICAgIGsgLT0gMTg2O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJldmlvdXMgSmFsYWxpIHllYXIuXG4gICAgICAgIGp5IC09IDE7XG4gICAgICAgIGsgKz0gMTc5O1xuICAgICAgICBpZiAoci5sZWFwID09PSAxKVxuICAgICAgICAgICAgayArPSAxO1xuICAgIH1cbiAgICBqbSA9IDcgKyBkaXYoaywgMzApO1xuICAgIGpkID0gbW9kKGssIDMwKSArIDE7XG4gICAgcmV0dXJuICB7IGp5OiBqeVxuICAgICAgICAsIGptOiBqbVxuICAgICAgICAsIGpkOiBqZFxuICAgIH07XG59XG5cbi8qXG4gQ2FsY3VsYXRlcyB0aGUgSnVsaWFuIERheSBudW1iZXIgZnJvbSBHcmVnb3JpYW4gb3IgSnVsaWFuXG4gY2FsZW5kYXIgZGF0ZXMuIFRoaXMgaW50ZWdlciBudW1iZXIgY29ycmVzcG9uZHMgdG8gdGhlIG5vb24gb2ZcbiB0aGUgZGF0ZSAoaS5lLiAxMiBob3VycyBvZiBVbml2ZXJzYWwgVGltZSkuXG4gVGhlIHByb2NlZHVyZSB3YXMgdGVzdGVkIHRvIGJlIGdvb2Qgc2luY2UgMSBNYXJjaCwgLTEwMDEwMCAob2YgYm90aFxuIGNhbGVuZGFycykgdXAgdG8gYSBmZXcgbWlsbGlvbiB5ZWFycyBpbnRvIHRoZSBmdXR1cmUuXG4gQHBhcmFtIGd5IENhbGVuZGFyIHllYXIgKHllYXJzIEJDIG51bWJlcmVkIDAsIC0xLCAtMiwgLi4uKVxuIEBwYXJhbSBnbSBDYWxlbmRhciBtb250aCAoMSB0byAxMilcbiBAcGFyYW0gZ2QgQ2FsZW5kYXIgZGF5IG9mIHRoZSBtb250aCAoMSB0byAyOC8yOS8zMC8zMSlcbiBAcmV0dXJuIEp1bGlhbiBEYXkgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGcyZChneSwgZ20sIGdkKSB7XG4gICAgdmFyIGQgPSBkaXYoKGd5ICsgZGl2KGdtIC0gOCwgNikgKyAxMDAxMDApICogMTQ2MSwgNClcbiAgICAgICAgKyBkaXYoMTUzICogbW9kKGdtICsgOSwgMTIpICsgMiwgNSlcbiAgICAgICAgKyBnZCAtIDM0ODQwNDA4O1xuICAgIGQgPSBkIC0gZGl2KGRpdihneSArIDEwMDEwMCArIGRpdihnbSAtIDgsIDYpLCAxMDApICogMywgNCkgKyA3NTI7XG4gICAgcmV0dXJuIGQ7XG59XG5cbi8qXG4gQ2FsY3VsYXRlcyBHcmVnb3JpYW4gYW5kIEp1bGlhbiBjYWxlbmRhciBkYXRlcyBmcm9tIHRoZSBKdWxpYW4gRGF5IG51bWJlclxuIChqZG4pIGZvciB0aGUgcGVyaW9kIHNpbmNlIGpkbj0tMzQ4Mzk2NTUgKGkuZS4gdGhlIHllYXIgLTEwMDEwMCBvZiBib3RoXG4gY2FsZW5kYXJzKSB0byBzb21lIG1pbGxpb25zIHllYXJzIGFoZWFkIG9mIHRoZSBwcmVzZW50LlxuIEBwYXJhbSBqZG4gSnVsaWFuIERheSBudW1iZXJcbiBAcmV0dXJuXG4gZ3k6IENhbGVuZGFyIHllYXIgKHllYXJzIEJDIG51bWJlcmVkIDAsIC0xLCAtMiwgLi4uKVxuIGdtOiBDYWxlbmRhciBtb250aCAoMSB0byAxMilcbiBnZDogQ2FsZW5kYXIgZGF5IG9mIHRoZSBtb250aCBNICgxIHRvIDI4LzI5LzMwLzMxKVxuICovXG5mdW5jdGlvbiBkMmcoamRuKSB7XG4gICAgdmFyIGpcbiAgICAgICAgLCBpXG4gICAgICAgICwgZ2RcbiAgICAgICAgLCBnbVxuICAgICAgICAsIGd5O1xuICAgIGogPSA0ICogamRuICsgMTM5MzYxNjMxO1xuICAgIGogPSBqICsgZGl2KGRpdig0ICogamRuICsgMTgzMTg3NzIwLCAxNDYwOTcpICogMywgNCkgKiA0IC0gMzkwODtcbiAgICBpID0gZGl2KG1vZChqLCAxNDYxKSwgNCkgKiA1ICsgMzA4O1xuICAgIGdkID0gZGl2KG1vZChpLCAxNTMpLCA1KSArIDE7XG4gICAgZ20gPSBtb2QoZGl2KGksIDE1MyksIDEyKSArIDE7XG4gICAgZ3kgPSBkaXYoaiwgMTQ2MSkgLSAxMDAxMDAgKyBkaXYoOCAtIGdtLCA2KTtcbiAgICByZXR1cm4gIHsgZ3k6IGd5XG4gICAgICAgICwgZ206IGdtXG4gICAgICAgICwgZ2Q6IGdkXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jalali-moment/jalali-moment.js\n");

/***/ })

});